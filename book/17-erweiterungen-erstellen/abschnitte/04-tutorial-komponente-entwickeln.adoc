=== Tutorial: Wir programmieren eine Komponente für Stellenanzeigen

Da Sie nun die Grundlagen der Joomla! API kennen, können wir mit der
Programmierung unserer ersten eigenen Joomla!-_Komponente_ beginnen. In
diesem kleinen Tutorial gehen wir davon aus, dass wir eine Komponente
zur Anzeige von Stellenangeboten programmieren möchten, die uns erlaubt,
im _Frontend_ je ein einzelnes Stellenangebot im Menü zu verlinken und
dieses Stellenangebot im _Backend_ über eine Listenansicht zu pflegen.
Jedes Stellenangebot soll über einen Titel und einen kleinen
Beschreibungstext verfügen.

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++04 |
|icn004 |Den gesamten Quellcode dieses Beispiels finden Sie auch in
meinem Github-Account unter
[.underline]#https://github.com/SniperSister/ComJobs#.
|===

==== Anlegen der Verzeichnisstruktur

Wir starten mit dem Anlegen der Verzeichnisstruktur. Legen Sie dafür an
einem Ort Ihrer Wahl das Verzeichnis _com++_++jobs_ an und erzeugen Sie
darin die folgende Verzeichnisstruktur:

* _admin_
* _controllers_
* _helpers_
* _language_
* _de-DE_
* _models_
* _fields_
* _forms_
* _rules_
* _sql_
* _updates_
* _updates/mysql_
* _tables_
* _views_
* _job_
* _job/tmpl_
* _jobs_
* _jobs/tmpl_
* _media_
* _images_
* _site_
* _language_
* _de-DE_
* _models_
* _views_
* _job_
* _job/tmpl_

==== Anlegen der XML-Definition

Anschließend legen Sie ins Wurzelverzeichnis (_com++_++jobs_) der
Erweiterung die Datei _jobs.xml_, die im Listing 17.8 abgebildet ist.
Diese Datei enthält Informationen zum Erweiterungspaket, ist im
XML-Format aufgebaut und erscheint in anderer Form auch in anderen
Paketverwaltungssystemen (z. B. _Package.json_ im Composer-Universum).

LISTING 17.8 jobs.xml

++<++?xml version="1.0" encoding="utf-8"?++>++

++<++extension type="component" version="3.7.0" method="upgrade"++>++

++<++name++>++COM++_++JOBS++<++/name++>++

++<++creationDate++>++March 2017++<++/creationDate++>++

++<++author++>++David Jardin++<++/author++>++

++<++authorEmail++>++d.jardin@djumla.de++<++/authorEmail++>++

++<++authorUrl++>++http://www.djumla.de++<++/authorUrl++>++

++<++copyright++>++Copyright 2017 David Jardin++<++/copyright++>++

++<++license++>++GPL v2 or later++<++/license++>++

++<++version++>++0.0.1++<++/version++>++

++<++description++>++COM++_++JOBS++_++DESCRIPTION++<++/description++>++

++<++!-- PHP-Skript wird ausgeführt bei Installation, Deinstallation und
Update --++>++

++<++scriptfile++>++script.php++<++/scriptfile++>++

++<++!-- SQL-Skript für die Installation --++>++

++<++install++>++

++<++sql++>++

++<++file driver="mysql"
charset="utf8"++>++sql/install.mysql.utf8.sql++<++/file++>++

++<++/sql++>++

++<++/install++>++

++<++!-- SQL-Skript für die Deinstallation --++>++

++<++uninstall++>++

++<++sql++>++

++<++file driver="mysql"
charset="utf8"++>++sql/uninstall.mysql.utf8.sql++<++/file++>++

++<++/sql++>++

++<++/uninstall++>++

++<++!-- SQL-Skripte für die Aktualisierung der Erweiterung --++>++

++<++update++>++

++<++schemas++>++

++<++schemapath type="mysql"++>++sql/updates/mysql++<++/schemapath++>++

++<++/schemas++>++

++<++/update++>++

++<++!-- Kopieranweisungen für das Frontend --++>++

++<++files folder="site"++>++

++<++filename++>++jobs.php++<++/filename++>++

++<++filename++>++controller.php++<++/filename++>++

++<++folder++>++views++<++/folder++>++

++<++folder++>++models++<++/folder++>++

++<++folder++>++language++<++/folder++>++

++<++/files++>++

++<++!-- Kopieranweisungen für das Media-Verzeichnis --++>++

++<++media destination="com++_++jobs" folder="media"++>++

++<++filename++>++index.html++<++/filename++>++

++<++folder++>++images++<++/folder++>++

++<++/media++>++

++<++languages folder="site"++>++

++<++language
tag="de-DE"++>++language/de-DE/de-DE.com++_++jobs.ini++<++/language++>++

++<++/languages++>++

++<++administration++>++

++<++!-- Administrations Menü --++>++

++<++menu
img="../media/com++_++jobs/images/jobs-16x16.png"++>++COM++_++JOBS++<++/menu++>++

++<++!-- Kopieranweisungen für das Backend --++>++

++<++files folder="admin"++>++

++<++filename++>++config.xml++<++/filename++>++

++<++filename++>++access.xml++<++/filename++>++

++<++filename++>++jobs.php++<++/filename++>++

++<++filename++>++controller.php++<++/filename++>++

++<++folder++>++sql++<++/folder++>++

++<++folder++>++tables++<++/folder++>++

++<++folder++>++models++<++/folder++>++

++<++folder++>++views++<++/folder++>++

++<++folder++>++controllers++<++/folder++>++

++<++folder++>++helpers++<++/folder++>++

++<++/files++>++

++<++languages folder="admin"++>++

++<++language
tag="de-DE"++>++language/de-DE/de-DE.com++_++jobs.ini++<++/language++>++

++<++language
tag="de-DE"++>++language/de-DE/de-DE.com++_++jobs.sys.ini++<++/language++>++

++<++/languages++>++

++<++/administration++>++

++<++!-- UPDATESERVER DEFINITION --++>++

++<++updateservers++>++

++<++server type="extension" priority="1" name="Jobs Update
Site"++>++http://yourdomain.com/update/jobs-update.xml++<++/server++>++

++<++/updateservers++>++

++<++/extension++>++

Diese Datei dient als zentrale Definitionsdatei und enthält daher
verschiedene Informationen zur Erweiterung:

* Angaben zum Erweiterungstyp, zur unterstützten Joomla!-Version und zu
der Installationsmethode: ++<++extension type="component"
version="3.7.0" method="upgrade"++>++
* allgemeine Angaben zum Titel der Komponente (++<++name++>++), zum
Autor (++<++author++>++, ++<++authorEmail++>++, ++<++authorUrl++>++),
zum Copyright (++<++copyright++>++), zur Lizenz (++<++license++>++), zur
Version (++<++version++>++) und einen kurzen Beschreibungstext
(++<++description++>++), wobei die Verwendung von Platzhaltern
(COM++_++JOBS++_++...) möglich ist. Diese Platzhalter werden bei Aufruf
im Backend durch den entsprechenden String in den Sprachdateien ersetzt.
* Angaben zu einem PHP-Skript, das bei Installation, Deinstallation und
Update ausgeführt wird:
++<++scriptfile++>++script.php++<++/scriptfile++>++
* Informationen zu den SQL-Dateien, die bei der Installation
(++<++install /++>++) und Deinstallation (++<++uninstall /++>++)
auszuführen sind. Dabei ist es möglich, unterschiedliche SQL-Dateien für
verschiedene Datenbanktypen (MySQL, MSSQL etc.) und Charsets (UTF-8
etc.) anzugeben.
* den ++<++update++>++-Tag, der uns erlaubt, für jeden Datenbanktyp ein
Verzeichnis anzugeben, das SQL-Dateien enthält, die beim Update
ausgeführt werden
* Angaben zu den Dateien, die bei der Installation in das
Frontend-Verzeichnis der Komponente (_/components/com++_++jobs_) zu
kopieren sind, wobei wir sowohl einzelne Dateien (++<++file++>++) als
auch ganze Ordner (++<++folder++>++) angeben können. Durch das
folder-Attribut sucht der Installer die angegebenen Dateien im
Unterverzeichnis _site_: ++<++files
folder="site"++>++...++<++/files++>++.
* Angaben zu den Dateien und Ordnern, die in das Medienverzeichnis der
Joomla!-Installation kopiert werden sollen. Das destination-Attribut
dient dabei dazu, den Installer anzuweisen, die Dateien im Verzeichnis
_/media/com++_++jobs_ abzulegen. Das folder-Attribut lässt den Installer
die angegebenen Dateien im Unterverzeichnis _/media_ des
Installationsarchivs suchen: ++<++media destination="com++_++jobs"
folder="media"++>++...++<++/media++>++
* Angaben zu den im Frontend verwendeten Sprachdateien mit dem bekannten
folder-Attribut sowie einer Angabe zur zugehörigen Sprache:
++<++languages folder="site"++>++ +
++<++language tag="de-DE"++>++...++<++/language++><++/languages++>++
* Angaben zu den Dateien, Ordnern (++<++files++>++), Sprachdateien
(++<++languages++>++) und Menüeinträgen (++<++menu++>++) des
Administrationsbereichs (++<++administration++>++)
* Eine Angabe zum XML-Dokument, das der Joomla!-Erweiterungsmanager zur
Überprüfung auf neue Erweiterungsversionen nutzt:
++<++updateservers++><++server type="extension" priority="1" name="Jobs
Update Site"++>++...++<++/server++><++/updateservers++>++

Über diese XML-Datei werden also alle wichtigen Informationen über die
Erweiterung an den Joomla!-Installer übergeben, der diese Informationen
dann einliest und auswertet.

==== Anlegen des Installationsskripts

Im nächsten Schritt legen wir im Verzeichnis _com++_++jobs_ das
Installationsskript _script.php_ an, das in Listing 17.9 abgebildet ist.

LISTING 17.9 script.php

++<++?php

defined('++_++JEXEC') or die;

/++**++

++*++ Installation class to perform additional changes during
install/uninstall/update

++*++

++*++ @since 0.0.1

++*++/

class Com++_++JobsInstallerScript

++{++

/++**++

++*++ Function to perform changes during install

++*++

++*++ @param JInstallerAdapterComponent $parent The class calling this
method

++*++

++*++ @return void

++*++/

public function install($parent)

++{++

// Initialize a new category

/++**++ @type JTableCategory $category ++*++/

$category = JTable::getInstance('Category');

// Check if the Uncategorised category exists before adding it

if (!$category-++>++load(array('extension' =++>++ 'com++_++jobs',
'title' =++>++ 'Uncategorised')))

++{++

$category-++>++extension = 'com++_++jobs';

$category-++>++title = 'Uncategorised';

$category-++>++description = '';

$category-++>++published = 1;

$category-++>++access = 1;

$category-++>++params = '++{++"category++_++layout":"","image":""}';

$category-++>++metadata = '++{++"author":"","robots":""}';

$category-++>++metadesc = '';

$category-++>++metakey = '';

$category-++>++language = '++*++';

$category-++>++checked++_++out++_++time =
JFactory::getDbo()-++>++getNullDate();

$category-++>++version = 1;

$category-++>++hits = 0;

$category-++>++modified++_++user++_++id = 0;

$category-++>++checked++_++out = 0;

// Set the location in the tree

$category-++>++setLocation(1, 'last-child');

// Check to make sure our data is valid

if (!$category-++>++check())

++{++

JFactory::getApplication()-++>++enqueueMessage($category-++>++getError());

return;

}

// Now store the category

if (!$category-++>++store(true))

++{++

JFactory::getApplication()-++>++enqueueMessage($category-++>++getError());

return;

}

// Build the path for our category

$category-++>++rebuildPath($category-++>++id);

}

}

/++**++

++*++ method to uninstall the component

++*++

++*++ @param JInstallerAdapterComponent $parent The class calling this
method

++*++

++*++ @return void

++*++/

public function uninstall($parent)

++{++

// $parent is the class calling this method

echo '++<++p++>++' . JText::++_++('COM++_++JOBS++_++UNINSTALL++_++TEXT')
. '++<++/p++>++';

}

/++**++

++*++ method to update the component

++*++

++*++ @param JInstallerAdapterComponent $parent The class calling this
method

++*++

++*++ @return void

++*++/

public function update($parent)

++{++

// $parent is the class calling this method

echo '++<++p++>++' . JText::++_++('COM++_++JOBS++_++UPDATE++_++TEXT') .
'++<++/p++>++';

}

/++**++

++*++ method to run before an install/update/uninstall method

++*++

++*++ @param string $type process type

++*++ @param JInstallerAdapterComponent $parent The class calling this
method

++*++

++*++ @return void

++*++/

public function preflight($type, $parent)

++{++

// $parent is the class calling this method

// $type is the type of change (install, update or discover++_++install)

echo '++<++p++>++' . JText::++_++('COM++_++JOBS++_++PREFLIGHT++_++' .
$type . '++_++TEXT') . '++<++/p++>++';

}

/++**++

++*++ method to run after an install/update/uninstall method

++*++

++*++ @param string $type process type

++*++ @param JInstallerAdapterComponent $parent The class calling this
method

++*++

++*++ @return void

++*++/

public function postflight($type, $parent)

++{++

// $parent is the class calling this method

// $type is the type of change (install, update or discover++_++install)

echo '++<++p++>++' . JText::++_++('COM++_++JOBS++_++POSTFLIGHT++_++' .
$type . '++_++TEXT') . '++<++/p++>++';

}

}

Das Skript beginnt wie alle weiteren Skripte, die wir im Verlauf der
Entwicklung anlegen werden, mit dem Aufruf defined('++_++JEXEC') or
die('Restricted access'), durch den sichergestellt wird, dass das Skript
nur innerhalb der Joomla-Umgebugn aufgerufen wird. Dies ist eine
Sicherheitsmaßnahme, um den direkten Aufruf der Datei via HTTP zu
unterdrücken, da dieser Aufruf ansonsten zu Fehlermeldungen führen
könnte, die interne Pfadangaben ausgeben.

Innerhalb der Datei finden wir die Klasse com++_++JobsInstallerScript,
die vom Installer während der Installation aufgerufen wird. Wichtig ist
dabei, dass die Klasse der Namenskonvention
com++_++KomponentennameInstallerScript entspricht, damit die
autoloader-Funktion des Systems korrekt arbeiten kann.

In der Klasse finden wir nun fünf verschiedene Methoden:

* install: Wird bei der Installation der Erweiterung aufgerufen
* uninstall: Wird bei der Deinstallation der Erweiterung aufgerufen
* update: Wird bei der Aktualisierung der Erweiterung aufgerufen
* preflight: Dient zum Ausführen von Prüfungen und Aktionen VOR der
Installation (return false; bricht die Installation ab)
* postflight: Dient zum Ausführen von Prüfungen und Aktionen NACH der
Installation

Im konkreten Fall nutzen wir die Methoden uninstall, update, preflight
und post­flight zum Ausgeben von Texten mittels
JText::++_++('SPRACHSTRING') und erzeugen in der install-Methode eine
leere Standard-Kategorie für unsere Erweiterung. Im Regelfall werden
diese Methoden jedoch für Systemprüfungen und umfangreichere
Update-Routinen genutzt, die sich nicht allein mittels SQL-Abfrage
realisieren lassen.

==== Anlegen der SQL-Dateien für Installation, Deinstallation und Update

Nun wechseln wir ins Verzeichnis _/admin/sql_ und legen dort die beiden
Dateien _install.mysql.utf8.sql_ und _uninstall.mysql.utf8.sql_ an, auf
die wir uns bereits in unserem XML-Dokument bezogen haben. Diese Dateien
enthalten das Datenbankschema unserer Erweiterung, das für den Betrieb
unter einem MySQL-Server benötigt wird. Wollen wir unsere Komponente
unter einem anderen SQL-Server betreiben, so muss für jedes System ein
eigener ++<++file++>++-Tag mit dem entsprechenden driver-Attribut in der
_jobs.xml_ angegeben werden.

Wir benötigen in unserer späteren Komponente fünf Spalten in unserer
Datenbanktabelle:

* id: enthält eine eindeutige ID für jeden Eintrag und wird unter MySQL
per auto++_++increment erhöht
* title: enthält den Titel des jeweiligen Jobangebots
* description: enthält eine per WYSIWYG-Editor definierte Beschreibung
* catid: enthält die ID der zugewiesenen Kategorie des Eintrags
* params: enthält JSON-kodierte Parameter – in unserem konkreten Fall
wird dort hinterlegt, ob die Kategorie des jeweiligen Eintrags angezeigt
werden soll

Die API geht an dieser Stelle standardmäßig davon aus, dass bestimmte
Datenbankspalten auch einen bestimmten Titel tragen, und baut in
verschiedenen Klassen (insbesondere JModel und JTable) auf die
Konventionen auf, die Sie in Tabelle 17.9 aufgelistet ­finden.

TABELLE 17.10 Konventionen für die Spaltenbenennung in der Joomla!-API

[width="100%",cols="23%,77%",]
|===
|Spalte |Beschreibung

|_Id_ |Enthält eine eindeutig identifizierbare ID für jeden Eintrag
(Primary Key)

|_Title_ |Enthält den Titel des Eintrags

|_Alias_ |Dient zur Speicherung des Alias, der als URL-Bestandteil für
suchmaschinenfreundliche URLs genutzt wird

|_Catid_ |Enthält die ID der zugewiesenen Kategorie

|_Language_ |Enthält den Tag der zugewiesenen Sprache für die
Inhaltsübersetzung

|_checked++_++out_ |Enthält die ID des Nutzers, der den Eintrag derzeit
bearbeitet

|_checked++_++out++_++time_ |Enthält den Zeitpunkt des
Bearbeitungsbeginns

|_asset++_++id_ |Wird zur Verknüpfung mit der Rechteverwaltung genutzt

|_Hits_ |Zugriffszähler, wird beim Aufruf hochgezählt

|_Ordering_ |Enthält eine Angabe zur Eintragsreihenfolge in der
jeweiligen Kategorie

|_Published_ |Enthält den Veröffentlichungsstatus (_veröffentlicht_,
_gesperrt_, _gelöscht_, ­__archiviert__)

|_parent++_++id_ |Wird von der Klasse JTableNested zur Zuordnung des
übergeordneten ­Beitrags genutzt

|_Lft_ |Wird von der Klasse JTableNested zur Generierung der
Baumstruktur genutzt

|_Rgt_ |Wird von der Klasse JTableNested zur Generierung der
Baumstruktur genutzt

|_Level_ |Wird von der Klasse JTableNested zur Generierung der
Baumstruktur genutzt

|_Params_ |Enthält die Parameter des jeweiligen Eintrags
|===

Aus der gewünschten Datenbankstruktur ergeben sich die Dateien
_install.mysql.utf8.sql_ (Listing 17.10) und _uninstall.mysql.utf8.sql_
(Listing 17.11), die den Platzhalter #++__++ nutzen. Dieser Platzhalter
wird beim Ausführen der Abfrage automatisch durch das Datenbankpräfix
der jeweiligen Joomla!-Installation ersetzt.

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++01 |
|icn001 |*Praxistipp:* Achten Sie darauf, dass Sie sämtliche SQL-Dateien
unbedingt UTF-8-codiert abspeichern, da es ansonsten zu unerwarteten
Verhaltensweisen während der Installation kommen kann.
|===

LISTING 17.10 install.mysql.utf8.sql

DROP TABLE IF EXISTS ++`++#++__++jobs++`++;

CREATE TABLE ++`++#++__++jobs++`++ (

++`++id++`++ int(11) NOT NULL AUTO++_++INCREMENT,

++`++title++`++ varchar(25) NOT NULL,

++`++description++`++ mediumtext NOT NULL,

++`++catid++`++ int(11) NOT NULL DEFAULT '0',

++`++params++`++ TEXT NOT NULL DEFAULT '',

PRIMARY KEY (++`++id++`++)

) ENGINE=MyISAM AUTO++_++INCREMENT=0 DEFAULT CHARSET=utf8;

LISTING 17.11 uninstall.mysql.utf8.sql

DROP TABLE IF EXISTS ++`++#++__++jobs++`++;

Nun möchten wir uns noch mit dem Unterverzeichnis
_/admin/sql/updates/mysql_ beschäftigen. In diesem Verzeichnis, das wir
in der _jobs.xml_ als Update-Verzeichnis für MySQL-Datenbanken
hinterlegt haben, können wir für *jede Version* unserer Erweiterung eine
eigene SQL-Datei ablegen, welche die in dieser Version vorgenommenen
Datenbankänderungen enthält. Ein Beispiel gefällig?

Stellen Sie sich vor, wir würden nun die erste Version 0.0.1 unserer
Erweiterung auf unserer Seite installieren, die Stellenangebote
einpflegen und dabei merken, dass uns eigentlich noch ein zusätzliches
Eingabefeld „Verfügbar ab“ fehlt, in dem wir eintragen möchten, ab wann
die jeweilige Stelle frei ist. Dazu ergänzen wir den entsprechenden Code
zur Darstellung und Editierung des Felds in unserer Erweiterung, setzen
die Versionsnummer der Erweiterung in der _jobs.xml_ auf 0.0.2 und legen
eine Datei _/admin/sql/updates/mysql/0.0.2.sql_ an. In dieser SQL-Datei
können wir das benötigte ALTER TABLE-Statement ablegen, welches das neue
Feld in der bereits bestehenden Tabelle ergänzt. Und wissen Sie was das
Schöne ist? Dieser Prozess funktioniert beim Update einer Erweiterung
vollautomatisch, und das sogar über mehrere Versionen hinweg. Habe ich
also z. B. noch Version 0.0.1 auf der Seite im Einsatz und installiere
Version 0.0.4, prüft der Installer, ob im angegebenen Update-Verzeichnis
die Dateien _0.0.2.sql_, _0.0.3.sql_ oder _0.0.4.sql_ existieren, und
führt diese dann aus. In unserem Fall reicht es aus, eine leere Datei
_0.0.1.sql_ im Verzeichnis abzulegen, da wir noch keine Updates
durchzuführen haben.

==== Anlegen des MVC-Patterns im Backend

===== Dispatcher

Nun geht es ans Eingemachte: Wir legen das MVC-Pattern für das Backend
an. Dazu starten wir mit der Datei, die beim Aufruf der Komponente im
Backend als Erstes geladen wird: mit dem sogenannten Dispatcher.

Diese Datei liegt nach der Installation im Backend-Ordner der jeweiligen
Komponente (_/administrator/components/com++_++jobs/_) und ist nach dem
Muster _KOMPONENTEN.php_ benannt. Daraus ergibt sich in unserem
konkreten Fall, dass wir im Ordner _admin_ die Datei _jobs.php_ anlegen,
deren Inhalt in Listing 17.12 angegeben ist.

LISTING 17.12 Backend-Dispatcher jobs.php

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

// Access check.

if (!JFactory::getUser()-++>++authorise('core.manage', 'com++_++jobs'))

++{++

new RuntimeException(JText::++_++('JERROR++_++ALERTNOAUTHOR'), 403);

}

// Require helper file

JLoader::register('JobsHelper', dirname(++__++FILE++__++) .
'/helpers/jobs.php');

// Import joomla controller library

jimport('joomla.application.component.controller');

// Get an instance of the controller prefixed by Jobs

$controller = JControllerLegacy::getInstance('Jobs');

// Perform the Request task

$controller-++>++execute(JFactory::getApplication()-++>++input-++>++get('task',
'', 'CMD'));

// Redirect if set by the controller

$controller-++>++redirect();

Auch diese Datei beginnt mit dem üblichen Check, ob die Datei innerhalb
des Frameworks aufgerufen wird. Anschließend wird über die Abfrage der
Methode authorise des JUser-Objekts geprüft, ob der entsprechende User
zum allgemeinen Aufruf (core.manage) unserer Jobs-Erweiterung
(com++_++jobs) berechtigt ist – sollte dies nicht der Fall sein, wird
eine entsprechende Exception erzeugt.

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++01 |
|icn001 |Diverse Quellen werden anstelle von Exceptions die Nutzung von
JError demonstrieren, diese API ist jedoch veraltet und wird in Zukunft
durch Exceptions ersetzt, Sie sollten also bereits jetzt auf Exceptions
setzen.
|===

Im weiteren Verlauf werden wir eine Funktion benötigen, die mehrfach
verwendet und daher in einer zentralen Datei, einem sog. _Helper_,
ausgelagert wird. Damit die _Autoloader_-Klasse der API (JLoader) diese
_Helper_-Klasse bei Bedarf aufrufen kann, müssen wir diese durch den
Aufruf der register-Methode an den Loader übergeben. Der erste Parameter
JobsHelper übergibt dabei den Namen der entsprechenden Klasse, der
zweite Parameter enthält den Pfad zu der Datei, in der die Klasse
abgelegt ist.

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++02 |
|icn002 |*Hinweis:* Ein _Autoloader_ erlaubt uns, eine Klasse zu nutzen,
ohne dass diese vorher explizit mittels require++_++once in das laufende
Programm eingebunden wurde. Dafür analysiert der Autoloader den Namen
der aufgerufenen Klasse und bindet, wenn er korrekt funktioniert,
automatisch die entsprechende Datei ein.
|===

[width="99%",cols="14%,86%",]
|===
| |
|===

Durch den Aufruf der statischen Methode getInstance('Jobs') können wir
nun eine _ControllerLegacy_-Instanz für unsere Komponente erstellen, an
die wir die auszuführende Aufgabe (task) aus der Nutzer-Anfrage zur
Ausführung (execute) übergeben. Da im Verlauf dieser Ausführung
eventuell Weiterleitungen gesetzt werden, müssen wir diese, nachdem der
Controller die execute-Aufgabe abgeschlossen hat, noch mittels
redirect-Methode ausführen. Dabei beachtet die getInstance-Methode
automatisch, welcher _Controller_ (durch die _controller_-Parameter in
der Nutzer-Anfrage) zurückgegeben werden muss.

Die Rolle des Dispatchers ist also relativ klar definiert: Er prüft, ob
ein Nutzer berechtigt ist, die Komponente auszuführen, ruft den
_Controller_ auf und übergibt diesem die Aufgabe, die jeweils zu
erledigen ist. Damit ist dann auch der Aufruf unseres MVC-Pattern
gestartet, sodass wir uns nun dem nächsten Puzzleteil widmen können: dem
Controller.

===== Die Backend-Controller

Legen Sie zuerst eine neue Datei _controller.php_ im Verzeichnis
_/admin_ an. Diese Datei dient uns als Standard-Controller, der zum
Einsatz kommt, wenn nicht explizit ein anderer Con­troller aufgerufen
wird.

Anderer Controller? Ja, davon gibt es tatsächlich mehrere! Es hat sich
eingebürgert, bei kleineren Erweiterungen drei Arten von Controllern zu
unterscheiden:

* Der _Haupt-Controller_ (_controller.php_), der im Stammverzeichnis der
jeweiligen Komponente liegt. Dieser ist dafür zuständig, eine
Listenansicht der Einträge zu generieren.
* Der _Listen-Controller_, welcher der Namenskonvention
_PLURALDESVERWALTETENOBEJKTS.php_ folgt (konkret also _jobs.php_) und im
Unterverzeichnis _/controllers_ liegt. In diesem Controller werden alle
Aufgaben verarbeitet, die mehrere Einträge betreffen (Löschen,
Sortieren, Veröffentlichen etc.).
* Der _Eintrags-Controller_, der nach dem Muster
_SINGULARDESVERWALTETENOBJEKTS.php_ benannt ist und ebenfalls im
Unterverzeichnis _/controllers_ liegt. Dieser verarbeitet Aufgaben, die
einen einzelnen Eintrag betreffen (Generieren der Formularansicht, Neu
anlegen, Editieren, Speichern).

Wir starten mit dem _Haupt-Controller_, den wir in der gerade angelegten
_controller.php_ definieren wollen. Den Code des Controllers finden Sie
in Listing 17.13.

LISTING 17.13 controller.php

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ General Controller of Jobs component

++*++

++*++ @since 0.0.1

++*++/

class JobsController extends JControllerLegacy

++{++

/++**++

++*++ The generic display task

++*++

++*++ @param bool $cachable is this view a cachabel one

++*++ @param array $urlparams url parameters

++*++

++*++ @return void

++*++/

public function display($cachable = false, $urlparams = array())

++{++

$input =& JFactory::getApplication()-++>++input;

// Set default view if not set

$input-++>++set('view', $input-++>++get("view", "Jobs", "CMD"));

// Call parent behavior

parent::display($cachable, $urlparams);

}

}

Wir leiten unseren JobsController von der Klasse JControllerLegacy ab.
Diese Klasse implementiert bereits alle nötigen Grundfunktionen eines
Controllers, sodass wir uns nur noch auf die einzelnen Funktionen
konzentrieren müssen, die der Controller einmal ausführen soll. Im
konkreten Fall reicht dafür die Methode dispay(), da der Controller ja
ausschließlich zur Anzeige der Listenansicht dient.

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++01 |
|icn001 |*Praxistipp:* Joomla! arbeitet bei der Benennung der Controller
nach der Konvention KomponentennameControllerControllername, wobei beim
_Haupt-Controller_ (_controller.php_) der Controllername weggelassen
wird.
|===

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++02 |
|icn002 |*Hinweis:* Die display()-Methode fungiert als Standard-Task und
wird immer ausgeführt, wenn kein gesonderter Task über die
execute-Methode im Dispatcher übergeben wurde.
|===

Innerhalb der Methode setzen wir durch den Aufruf von
$input-++>++set('view', $input-++>++get("view","Jobs","CMD")) die View
Jobs als Standard-View, die aber durch Angabe des URL-Parameters view
auch manuell überschrieben werden kann. Diese View wird durch den Aufruf
von parent::display() aktiviert, woraufhin die Ausführung des Programms
in die jeweilige View springt.

Anschließend kümmern wir uns um die _Listen_- bzw.
_Eintrags-Controller_, die wir in die Dateien
_/admin/controllers/jobs.php_ (Liste) bzw. _/admin/controllers/job.php_
(Eintrag) ablegen. Der _Listen-Controller_ ist schnell definiert und
findet sich in Listing 17.14.

LISTING 17.14 Listen-Controller jobs.php

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Jobs Controller

++*++

++*++ @since 0.0.1

++*++/

class JobsControllerJobs extends JControllerAdmin

++{++

/++**++

++*++ Description

++*++

++*++ @param string $name model name

++*++ @param string $prefix model prefix

++*++

++*++ @return bool++|++JModelLegacy

++*++/

public function getModel($name = 'Job', $prefix = 'JobsModel')

++{++

$model = parent::getModel($name, $prefix, array('ignore++_++request'
=++>++ true));

return $model;

}

}

Wir leiten den _Listen-Controller_ von der Klasse JControllerAdmin ab,
wodurch wir auf die bereits definierten Methoden zum Löschen,
Veröffentlichen, Sperren, Archivieren und Sortieren von Einträgen
zurückgreifen können, ohne diese erneut in unsere Controller definieren
zu müssen. Cool, oder?

Wir müssen allerdings das von diesem Controller verwendete Model manuell
„umbiegen“, da ein Controller standardmäßig das Model verwendet, das den
gleichen Namen trägt wie er selber (_jobs.php_). Da wir unsere
Bearbeitungsmethoden jedoch im Job-Model (Singular!) untergebracht
haben, überschreiben wir die Methode getModel und setzen dort unseren
gewünschten Namen im Singular ($name = 'Job') ein.

Nun fehlt nur noch der Eintrags-Controller, der dankenswerterweise sogar
noch viel unkomplizierter ist, wie Sie in Listing 17.15 sehen können.

LISTING 17.15 Eintrags-Controller job.php

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Job Controller

++*++

++*++ @since 0.0.1

++*++/

class JobsControllerJob extends JControllerForm

++{++

}

Der Eintrags-Controller wird lediglich von der Klasse JControllerForm
abgeleitet, da diese bereits alle benötigten Methoden zur Generierung
und Speicherung der Editierungsformulare mitbringt.

===== Die Backend-Models

So weit, so gut, wir kommen jetzt zu den Backend-Models, die wir im
Verzeichnis _/admin/models_ ablegen.

Auch hier gibt es zwei Modelle:

* _job.php_ enthält alle Methoden, die zur Änderung eines Eintrags
(Abrufen, Speichern, Löschen, Status verändern, Formular generieren
etc.) nötig sind.
* _jobs.php_ ruft die Daten für die Listenansicht ab und bringt keine
Methoden zur Veränderung der Daten mit.

Diese Trennung unterscheidet sich auf den ersten Blick von der
Unterteilung im _Controller_ (betrifft einen Eintrag vs. betrifft
mehrere Einträge). Das macht aber durchaus Sinn, da auch das Löschen von
mehreren Einträgen auf Ebene des _Models_ nicht „in einem Rutsch“,
sondern Eintrag für Eintrag durchgeführt wird. Dadurch wird aus einer
Operation, die im _Controller_ mehrere Einträge betrifft, auf Ebene des
_Models_ doch wieder nur eine Einzeloperation. Daher sind hier alle
Änderungsoptionen in der _job.php_ abgelegt.

Betrachten wir zuerst die Datei _jobs.php_, die in Listing 17.16
abgebildet ist.

LISTING 17.16 Listen-Model jobs.php

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ JobsList Model

++*++

++*++ @since 0.0.1

++*++/

class JobsModelJobs extends JModelList

++{++

/++**++

++*++ Method to build an SQL query to load the list data.

++*++

++*++ @return string An SQL query

++*++/

protected function getListQuery()

++{++

// Create a new query object.

$db = JFactory::getDBO();

$query = $db-++>++getQuery(true);

// Select some fields

$query-++>++select('++*++');

// From the jobs table

$query-++>++from('#++__++jobs');

// Filter by category.

$categoryId = $this-++>++getState('filter.category++_++id');

if (is++_++numeric($categoryId))

++{++

$query-++>++where('catid = ' . (int) $categoryId);

}

// Add the list ordering clause.

$orderCol = $this-++>++state-++>++get('list.ordering');

$orderDirn = $this-++>++state-++>++get('list.direction');

$query-++>++order($db-++>++escape($orderCol . ' ' . $orderDirn));

return $query;

}

/++**++

++*++ Method to auto-populate the model state.

++*++

++*++ @param string $ordering name if column that should be used for
order

++*++ @param string $direction ordering direction

++*++

++*++ @return void

++*++

++*++ @note Calling getState in this method will result in recursion.

++*++/

protected function populateState($ordering = null, $direction = null)

++{++

// Load the filter state.

$categoryId = $this-++>++getUserStateFromRequest($this-++>++context .
'.filter.category++_++id', 'filter++_++category++_++id', '');

$this-++>++setState('filter.category++_++id', $categoryId);

// List state information.

parent::populateState('title', 'asc');

}

}

Dieses Model, das erneut der Namenskonvention
KomponentennameModelModelname folgt, wird von der Klasse JModelList
abgeleitet. Dieses Model definiert die für die Erzeugung der
Listenansicht relevanten Methoden zum Abruf der Eintragsliste (_Items_),
der Blätter-Funktion (_Pagination_) sowie der Gesamteintragszahl
(_Total_) und benötigt dafür nur die SQL-Abfrage zur Abfrage der
Einträge. Diese Abfrage definieren wir in der Methode getListQuery(),
die dann vom Model verwendet wird. Dabei nutzen wir die bereits bekannte
Klasse JDatabaseQuery, die über den Aufruf $db-++>++getQuery vom
Datenbankobjekt abgerufen wird.

Da wir die Liste der Stellenanzeigen später im Backend nach der
jeweiligen Kategorie filtern wollen, müssen wir diese Filterfunktion
noch implementieren. Hierbei kommt in Joomla der sogenannte State zum
tragen. Ein State enthält alle derzeit gesetzten Filter-, Blätter- und
Sortieroptionen, wobei es sich hierbei z.B. um einen Freitext-Filter,
die ID des aktuellen Eintrags, die ausgewählte Seite in der
Blätterfunktion oder eine Sortierrichtung handeln kann. Joomla setzt
viele dieser Status-Angaben bereits automatisch (z.B. die
Blätterfunktion), unseren Kategorie-Filter jedoch müssen wir händisch
implementieren. Dafür nutzen wir die Methode populateState(), in der
Joomla zu Beginn des Prozesses das jeweilige State Objekt des Models
erzeugt. Diesen Filter können wir anschließend in der getListQuery()
Methode abrufen und in Form eines where-Filters integrieren.

Bisher war der Model-Code noch sehr überschaubar und leicht zu
verstehen, doch nun kommen wir zum Formular-Model _job.php_, das in
Listing 17.17 abgebildet ist.

LISTING 17.17 Eintrags-Models job.php

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Job Model

++*++

++*++ @since 0.0.1

++*++/

class JobsModelJob extends JModelAdmin

++{++

/++**++

++*++ Returns a reference to the a Table object, always creating it.

++*++

++*++ @param string $type The table type to instantiate

++*++ @param string $prefix A prefix for the table class name. Optional.

++*++ @param array $config Configuration array for model. Optional.

++*++

++*++ @return JTable A database table object

++*++/

public function getTable($type = 'Jobs', $prefix = 'JobsTable', $config
= array())

++{++

return JTable::getInstance($type, $prefix, $config);

}

/++**++

++*++ Method to get the record form.

++*++

++*++ @param array $data Data for the form.

++*++ @param boolean $loadData True if the form is to load its own data
(default case), false if not.

++*++

++*++ @return mixed A JForm object on success, false on failure

++*++/

public function getForm($data = array(), $loadData = true)

++{++

// Get the form.

$form = $this-++>++loadForm('com++_++jobs.job', 'job', array('control'
=++>++ 'jform', 'load++_++data' =++>++ $loadData));

if (empty($form))

++{++

return false;

}

return $form;

}

/++**++

++*++ Method to get the data that should be injected in the form.

++*++

++*++ @return mixed The data for the form.

++*++/

protected function loadFormData()

++{++

// Check the session for previously entered form data.

$data =
JFactory::getApplication()-++>++getUserState('com++_++jobs.edit.job.data',
array());

if (empty($data))

++{++

$data = $this-++>++getItem();

// Prime some default values.

if ($this-++>++getState('job.id') == 0)

++{++

$app = JFactory::getApplication();

$data-++>++set('catid', $app-++>++input-++>++get('catid',
$app-++>++getUserState('com++_++jobs.jobs.filter.category++_++id'),
'int'));

}

}

$this-++>++preprocessData('com++_++jobs.job', $data);

return $data;

}

}

Wir leiten dieses Model von der Klasse JModelAdmin ab, die sich wiederum
von JModelForm ableitet. Dadurch beinhaltet unser Model bereits alle
nötigen Methoden zum Hinzufügen, Laden und Modifizieren eines Eintrags
sowie zum Parsen und Validieren eines mittels JForm definierten
Formulars.

Aufgrund der Benennung unserer Klasse (Job, also Singular) müssen wir
jedoch noch manuell die korrekte Tabellen-Klasse (JTable) zuweisen, die
Joomla! zur Interaktion mit der Datenbank nutzt. Das JModelAdmin lädt
hier standardmäßig die Table-Klasse, die der eigenen Benennung
entspricht (also JobTableJob), unsere Table-Klasse nutzt jedoch den
Plural Jobs im Namen, weshalb wir die Methode getTable überschreiben
müssen, damit das Model die korrekte Tabelle nutzen kann.

Zudem müssen wir die Methode getForm implementieren, welche die
JModelForm-Methode loadForm nutzt, um das job-Formular zu laden, das wir
gleich im Unterverzeichnis _forms_ anlegen werden.

Anschließend überschreiben wir die Methode loadFormData, die vom
JModelForm aufgerufen wird, um Daten, die bereits im Formular
eingegeben, aber noch nicht gespeichert wurden, wieder im Formular
anzeigen zu lassen. Wozu wir das tun? Ganz einfach – Stellen Sie sich
vor, Sie würden eine fehlerhafte Eingabe vornehmen und trotzdem auf
_Speichern_ drücken. Die Formular-Validierung verhindert nun das
Speichern des fehlerhaften Eintrags und ruft stattdessen erneut das
Editierungsformular auf – allerdings wären dabei unsere Eingabedaten
verloren gegangen. Um dies zu verhindern, rufen wir über die Methode
getUserState die zuvor in der Session des Nutzers abgelegten
Formulardaten erneut ab und zeigen das Formular mit diesen Daten an.

Außerdem setzen wir, wenn es sich um ein neues Stellenangebot handelt,
die aktuell in der Listenansicht ausgewählte Kategorie aus dem Filter
als Standardkategorie ins Formular ein.

===== Das Backend-Formular

Wie aber sieht dieses mysteriöse Formular aus, auf das wir uns hier die
ganze Zeit beziehen? Das Formular trägt den Dateinamen _job.xml_, wird
im Unterordner _/admin/models/forms_ abgelegt und ist in Listing 17.18
abgebildet.

LISTING 17.18 job.xml – XML-Definition des Formulars für die Validierung
mittels JForm

++<++?xml version="1.0" encoding="utf-8"?++>++

++<++form

addrulepath="/administrator/components/com++_++jobs/models/rules"

++>++

++<++fieldset name="details"++>++

++<++field

name="id"

type="hidden"

/++>++

++<++field

name="title"

type="text"

label="COM++_++JOBS++_++JOB++_++FIELD++_++TITLE++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++TITLE++_++DESC"

size="40"

class="inputbox validate-title"

validate="title"

required="true"

default=""

/++>++

++<++field

name="description"

type="editor"

label="COM++_++JOBS++_++JOB++_++FIELD++_++DESCRIPTION++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++DESCRIPTION++_++DESC"

required="true"

filter="JComponentHelper::filterText"

/++>++

++<++field

name="catid"

type="category"

extension="com++_++jobs"

class="inputbox"

default=""

label="COM++_++JOBS++_++JOB++_++FIELD++_++CATID++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++CATID++_++DESC"

required="true"

++>++

++<++option
value="0"++>++JOPTION++_++SELECT++_++CATEGORY++<++/option++>++

++<++/field++>++

++<++/fieldset++>++

++<++fields name="params"++>++

++<++fieldset

name="params"

label="JGLOBAL++_++FIELDSET++_++DISPLAY++_++OPTIONS"

++>++

++<++field

name="show++_++title"

type="list"

label="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++TITLE++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++TITLE++_++DESC"

default=""

++>++

++<++option value="0"++>++JHIDE++<++/option++>++

++<++option value="1"++>++JSHOW++<++/option++>++

++<++/field++>++

++<++field

name="show++_++category"

type="list"

label="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++CATEGORY++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++CATEGORY++_++DESC"

default=""

++>++

++<++option value="0"++>++JHIDE++<++/option++>++

++<++option value="1"++>++JSHOW++<++/option++>++

++<++/field++>++

++<++/fieldset++>++

++<++/fields++>++

++<++/form++>++

Diese XML-Datei dient als Herzstück unseres Administrationsformulars, da
hier die auszufüllenden Felder und Parameter im bereits bekannten
XML-Format hinterlegt sind. Wenn wir das Dokument genauer betrachten,
stellen wir fest, dass hier zwei verschiedene Feldgruppen (Fieldsets)
definiert sind:

* Das details-Fieldset enthält die Eingabefelder für die ID des
Jobangebots, den Titel, die Beschreibung und die zugehörige Kategorie.
* Das params-Fieldset enthält die Parameter des jeweiligen Jobangebots,
die in der Datenbank JSON-kodiert in einem gemeinsamen Feld (params)
gespeichert werden sollen. Daher werden alle Felder dieses Fieldsets in
einem gemeinsamen ++<++fields++>++-Tag abgelegt, der dazu führt, dass
sich die einzelnen Felder später gesammelt über ein Array abrufen lassen
(siehe Bild 17.2).

image:book/17-erweiterungen-erstellen/media/3.png[book/17-erweiterungen-erstellen/media/3,width=548,height=155]

BILD 17.2 Beide Parameter sind in einem Params-Array enthalten und
lassen sich daher im PHP-Skript über $params++[++'show++_++title'++]++
und $params++[++'show++_++categorie'++]++ ansprechen. Dies erlaubt eine
leichte Konvertierung ins JSON-Format.

Die einzelnen Felder bieten nun je nach Typ diverse Attribute, um ein
Feld z.B. zum Pflichtfeld zu machen (required), schädlichen Code zu
filtern (filter) oder mittels validate-Attribut eine spezielle
Validierung der Eingabe vorzunehmen. Joomla! sieht hier bereits
verschiedene Validierungsmethoden vor, wir möchten jedoch eine eigene
Validierungsregel erstellen, um sicherzustellen, dass im _Titel_-Feld
keine Zahlen enthalten sind. Falls Sie über die Sinnhaftigkeit dieser
Regel nachdenken – im Zweifelsfalle gehen wir einfach davon aus, dass
der Kunde es sich so gewünscht hat. Wir benötigen eine auf PHP
basierende Regel für die serverseitige Prüfung.

Ich habe diese Validierungsregel title genannt und zum validate-Attribut
des title-Fields hinzugefügt. Damit die JForm Klasse weiß, in welchem
Verzeichnis der serverseitige Code für diese selbst definierte Regel zu
finden ist, geben wir dieses Verzeichnis im add­rulepath-Attribut des
++<++form++>++-Tags an.

[width="99%",cols="14%,86%",options="header",]
|===
|CHV++_++BOX++_++ID++_++01 |
|icn001 |*Praxistipp:* Vergessen Sie keinesfalls die Angabe des
versteckten Felds für die ID, da andernfalls, beim Editieren eines
Eintrags, für jedes Speichern ein neuer Eintrag angelegt werden würde.
|===

Im Anschluss daran definieren wir noch die Regel zur serverseitigen
Validierung des Titel-Felds, wofür wir im Unterordner
_/admin/models/rules_ die Datei _title.php_ anlegen und dort den Code
aus Listing 17.19 ablegen.

LISTING 17.19 title.php – Regel zur serverseitigen Validierung

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Form Rule class for the Joomla Framework.

++*++

++*++ @since 0.0.1

++*++/

class JFormRuleTitle extends JFormRule

++{++

/++**++

++*++ The regular expression.

++*++

++*++ @access protected

++*++ @var string

++*++ @since 1.6

++*++/

protected $regex = '^++[++^0-9++]++{plus}$';

}

Diese Klasse erweitert die Basisklasse JFormRule und hinterlegt den
bekannten Code zur Validierung durch die test-Methode der Klasse
JFormRule.

===== Anlegen der Table-Klasse

Nachdem unser Formular so weit vollendet ist, können wir uns um die
Speicherung der Einträge in der Datenbank kümmern, die über eine sog.
_Table_-Klasse erfolgt. Diese Klasse haben wir bereits in Kapitel
17.4.5.3, „Die Backend-Models“, kennengelernt, jedoch möchte ich
nochmals kurz darauf eingehen, welche Aufgabe diese Klasse eigentlich
hat.

Die _Table_-Klasse liegt als Abstraktionsschicht zwischen dem Model der
Erweiterung und der Datenbank des Systems und ist zentraler Bestandteil
der ORM-Implementierung der API. Die _Table_-Klasse wird von den Models
genutzt, um Schreibzugriffe jeglicher Art nicht direkt als SQL-Abfrage
definieren zu müssen, sondern auf die Abstraktionsschicht der
_Table_-Klasse und deren Methoden zurückgreifen zu können. Dadurch ist
es möglich, einen Datensatz wie ein Objekt zu behandeln, was die
Handhabung enorm erleichtert.

Bevor wir die Klasse nutzen können, müssen wir sie vorher in der Datei
_/admin/tables/jobs.php_ definieren (siehe Listing 17.20).

LISTING 17.20 Table-Klasse für die Jobs-Tabelle

++<++?php

// No direct access

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Jobs Table class

++*++

++*++ @since 0.0.1

++*++/

class JobsTableJobs extends JTable

++{++

/++**++

++*++ Ensure the params and metadata in json encoded in the bind method

++*++

++*++ @var array

++*++/

protected $++_++jsonEncode = array('params');

/++**++

++*++ Constructor

++*++

++*++ @param JDatabaseDriver &$db connector object

++*++/

public function ++__++construct(&$db)

++{++

parent::++__++construct('#++__++jobs', 'id', $db);

}

}

Unser Beispiel ist hierbei sehr überschaubar, da wir im wesentlichen nur
drei wichtige Angaben machen müssen. Zum Ersten setzen wir in der
++__++construct()-Methode den Namen der Tabelle in der Datenbank, sowie
den Namen der Spalte, die den Primary Key enthält.

Außerdem setzen wir im $++_++jsonEncode Property der Klasse die Namen
der Spalten, die von JTable automatisch in ein JSON String encodiert
bzw. decodiert werden sollen. Über diesen Trick können wir beliebige
Arrays zum Params-Property hinzufügen während Joomla für uns vollkommen
transparent die Codierung und Speicherung in der Datenbank übernimmt. .

===== Anlegen der View für die Listenansicht

Wir haben nun alle benötigten Klassen für die Datenverarbeitung zusammen
und können uns jetzt um die Darstellung kümmern. Dafür legen wir im
Ordner _/admin/views/jobs_ die Datei _view.html.php_ an, die Sie in
Listing 17.21 abgebildet finden.

LISTING 17.21 Listenansicht im Backend

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Jobs View

++*++

++*++ @since 1.0.0

++*++/

class JobsViewJobs extends JViewLegacy

++{++

protected $items;

protected $pagination;

protected $state;

/++**++

++*++ Jobs view display method

++*++

++*++ @param string $tpl templae name

++*++

++*++ @return void

++*++/

public function display($tpl = null)

++{++

// Get data from the model

$this-++>++items = $this-++>++get('Items');

$this-++>++pagination = $this-++>++get('Pagination');

$this-++>++state = $this-++>++get('State');

// Check for errors.

if (count($errors = $this-++>++get('Errors')))

++{++

throw new RuntimeException(implode('++<++br /++>++', $errors), 500);

}

// Set the toolbar

JobsHelper::addSubmenu('jobs');

$this-++>++addToolBar();

$this-++>++sidebar = JHtmlSidebar::render();

// Add CSS for icon

JFactory::getDocument()-++>++addStyleDeclaration('.icon-jobs
++{++background:url(../media/com++_++jobs/images/jobs-16x16.png)}');

// Display the template

parent::display($tpl);

}

/++**++

++*++ Setting the toolbar

++*++

++*++ @return void

++*++/

protected function addToolBar()

++{++

$state = $this-++>++get('State');

$canDo = JHelperContent::getActions('com++_++jobs', 'category',
$state-++>++get('filter.category++_++id'));

$user = JFactory::getUser();

JToolBarHelper::title(JText::++_++('COM++_++JOBS++_++MANAGER++_++JOBS'),
'jobs');

if ($canDo-++>++get('core.create'))

++{++

JToolBarHelper::addNew('job.add');

}

if ($canDo-++>++get('core.edit'))

++{++

JToolBarHelper::editList('job.edit');

}

if ($canDo-++>++get('core.delete'))

++{++

JToolBarHelper::deleteList('', 'jobs.delete');

}

if ($user-++>++authorise('core.admin', 'com++_++jobs') ++||++
$user-++>++authorise('core.options', 'com++_++jobs'))

++{++

JToolBarHelper::divider();

JToolBarHelper::preferences('com++_++jobs');

}

JHtmlSidebar::setAction('index.php?option=com++_++jobs&view=jobs');

JHtmlSidebar::addFilter(

JText::++_++('JOPTION++_++SELECT++_++CATEGORY'),

'filter++_++category++_++id',

JHtml::++_++('select.options', JHtml::++_++('category.options',
'com++_++jobs'), 'value', 'text',
$state-++>++get('filter.category++_++id'))

);

}

}

Unsere _View_ leiten wir von der Klasse JView ab, die uns alle
anstehenden Aufgaben (Laden des passenden Templates, Initialisieren des
Output-Buffers etc.) insoweit abnimmt, als dass wir uns nur noch um die
Implementierung unserer display()-Methode kümmern müssen.

Die erste Frage, die sich hier nun aufdrängt, ist: Wenn unsere _View_
direkt vom Controller aufgerufen wurde, wie holen wir dann die Daten aus
dem _Model_? Dazu denken wir nochmals an unser Jobs-Model zurück und
erinnern uns daran, dass wir dieses _Model_ von der Klasse JModelList
abgeleitet haben. Diese Klasse wiederum implementiert die Methode
getItems(), welche die Listeneinträge anhand der im _Model_ definierten
SQL-Abfrage abruft. Die Klasse JView bietet uns eine „Abkürzung“, um auf
diese Klasse zuzugreifen: Der Aufruf $this-++>++items =
$this-++>++get('Items') in der display()-Methode greift im Hintergrund
auf die erwähnte getItems()-Methode unseres _Models_ zurück – um die
Initialisierung des _Models_ müssen wir uns dabei nicht kümmern.

In identischer Art und Weise besorgen wir uns auch die Seitennavigation
(Blättern durch die Liste) mittels $this-++>++get('Pagination') und des
States und prüfen, ob dieser Vorgang Fehler hervorgerufen hat, die wir
im Fall der Fälle als Exception ausgeben würden.

Damit wir diese lokalen Variablen ($items und $pagination) auch im
späteren _Template_ verwenden können, haben wir sie durch die
entsprechenden Zuweisungen ($this-++>++items = $this-++>++get('Items'))
dem View-Objekt zugewiesen, wodurch sie automatisch im Template
verfügbar werden.

Bevor wir mittels parent::display($tpl); das Parsen des Templates
auslösen, rufen wir die Methode addToolBar auf, die wir aus
Übersichtsgründen in eine eigene Funktion ausgelagert haben.

Die Methode addToolBar nutzen wir zur Generierung der Werkzeugleiste,
die sich in der oberen linken Ecke der Administration befindet.
Sinnvollerweise sollten wir dabei nur die Buttons einblenden, die der
jeweilige Nutzer aufgrund seiner Berechtigungen auch nutzen darf,
weshalb wir über die Klasse JHelperContent eine Liste aller Aktionen
generieren, die der jeweilige Nutzer in der jeweiligen Kategorie (daher
die Übergabe der Kategorie-ID) ausführen darf. Anschließend setzen wir
durch die Nutzung des JToolBarHelper einen entsprechenden Titel, der
links oberhalb der Erweiterung angezeigt wird, und prüfen anschließend
für jede Aktion, ob der Nutzer diese ausführen darf. Falls ja, fügen wir
den entsprechenden Toolbar-Button hinzu. Die Methoden addNew, editList
und deleteList akzeptieren zwei Parameter, wobei der erste Parameter
nach dem Muster _CONTROLLER.AKTION_ ausgebaut ist und der zweite die
Beschriftung generiert. Ein Klick auf den Delete-Button würde also z.B.
die delete-Methode des Jobs-Controllers aufrufen.

Im nächsten Schritt kümmern wir uns um das Ausgabe-Template der
Listenansicht, wobei das System, falls nicht bewusst ein anderes
Template aufgerufen wurde, das default-Template lädt, das in der Datei
_/admin/views/jobs/tmpl/default.php_ definiert wird. Den Code dieses
Templates finden Sie in Listing 17.22.

LISTING 17.22 default.php – Backend-Template für die Listenansicht

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

// No direct access to this file

defined('++_++JEXEC') or die('Restricted Access');

// Load tooltip behavior

JHtml::++_++('behavior.tooltip');

JHtml::++_++('formbehavior.chosen', 'select');

?++>++

++<++form action="++<++?php echo
JRoute::++_++('index.php?option=com++_++jobs&view=jobs'); ?++>++"
method="post" name="adminForm" id="adminForm"++>++

++<++div id="j-sidebar-container" class="span2"++>++

++<++?php echo $this-++>++sidebar; ?++>++

++<++/div++>++

++<++div id="j-main-container" class="span10"++>++

++<++?php if (empty($this-++>++items)): ?++>++

++<++div class="alert alert-no-items"++>++

++<++?php echo JText::++_++('JGLOBAL++_++NO++_++MATCHING++_++RESULTS');
?++>++

++<++/div++>++

++<++?php else: ?++>++

++<++table class="table table-striped" id="jobList"++>++

++<++thead++>++

++<++?php echo $this-++>++loadTemplate('head'); ?++>++

++<++/thead++>++

++<++tfoot++>++

++<++?php echo $this-++>++loadTemplate('foot'); ?++>++

++<++/tfoot++>++

++<++tbody++>++

++<++?php echo $this-++>++loadTemplate('body'); ?++>++

++<++/tbody++>++

++<++/table++>++

++<++?php endif; ?++>++

++<++input type="hidden" name="task" value="" /++>++

++<++input type="hidden" name="boxchecked" value="0" /++>++

++<++input type="hidden" name="filter++_++order" value="++<++?php echo
$this-++>++escape($this-++>++state-++>++get('list.ordering')); ?++>++"
/++>++

++<++input type="hidden" name="filter++_++order++_++Dir"
value="++<++?php echo
$this-++>++escape($this-++>++state-++>++get('list.direction')); ?++>++"
/++>++

++<++?php echo JHtml::++_++('form.token'); ?++>++

++<++/div++>++

++<++/form++>++

Dieses Template besteht, wie Sie sehen, im Wesentlichen aus HTML-Code,
der durch einige PHP-Aufrufe ergänzt wird. Der Aufruf
JHtml::++_++('behavior.tooltip'); lädt die JavaScript-Bibliothek der
Joomla!-API, die für die Generierung von Tooltipps benötigt wird.
JHtml::++_++('formbehavior.chosen', 'select'); lädt in ähnlicher Art und
Weise die JavaScript-Bibliothek Chosen, die wir für das Filter-Select in
der Sidebar benötigen. Die Funktion JRoute::++_++(...) gibt eine
automatisch an die jeweilige Domain angepasste URL zurück, die aus dem
übergebenen Parameter generiert wurde, und mit dem Aufruf von ++<++?php
echo JHtml::++_++('form.token'); ?++>++ stellen wir sicher, dass das
Token zur Verhinderung von _CSRF_-Attacken (siehe Kapitel 21.2.5, „Cross
Site Request Forgery“) gesetzt wird. Über ++<++?php echo
$this-++>++sidebar; ?++>++ geben wir die in der View erzeugte Sidebar
aus.

Um unser Template übersichtlicher zu gestalten, haben wir die Teile, die
für die Generierung von Kopf-, Fuß- und Mittelteil der Liste zuständig
sind, in eigene Templates ausge­lagert, die mittels
$this-++>++loadTemplate(...) eingefügt werden.

Der Pragmatiker wird sich die Frage stellen: Warum gibt es hier
eigentlich einen umschließenden ++<++form++>++-Tag? Dies hängt damit
zusammen, dass unsere Liste ja nicht nur rein zur Darstellung der Seite
dient, sondern auch Interaktionsmöglichkeiten (Löschen, Blättern,
Hinzufügen, Editieren) bieten soll. Deshalb bietet es sich an, ein
Formular zu verwenden und die jeweiligen Parameter (Aktion, ID des
Eintrags) mittels POST-Request zu übermitteln.

Außerdem sollten Sie darauf achten, dass die beiden versteckten Felder
task und boxchecked in ihrer Listenansicht vorhanden sind, da die
Toolbar diese Felder zum korrekten Arbeiten benötigt. Gleiches gilt für
die beiden Felder filter++_++order und filter++_++order++_++Dir, die für
die Sortierungfunktion benötigt werden. Last but not least muss darauf
geachtet werden, dass das Formular über id="adminForm" als zentrales
Management-Formular der jeweiligen Seite markiert wird.

Nun schauen wir uns die weiteren Teile des Templates an, die wir hier
einbinden. Beginnen wir mit dem _head_-Template, das in der Datei
_/admin/views/jobs/tmpl/default++_++head.php_ abgelegt wird und in
Listing 17.23 abgebildet ist.

LISTING 17.23 Listenkopf default++_++head.php

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted Access');

$listOrder =
$this-++>++escape($this-++>++state-++>++get('list.ordering'));

$listDirn =
$this-++>++escape($this-++>++state-++>++get('list.direction'));

?++>++

++<++tr++>++

++<++th width="1%" class="hidden-phone center"++>++

++<++?php echo JHtml::++_++('grid.checkall'); ?++>++

++<++/th++>++

++<++th class="title"++>++

++<++?php echo JHtml::++_++('grid.sort', 'JGLOBAL++_++TITLE', 'title',
$listDirn, $listOrder); ?++>++

++<++/th++>++

++<++th width="1%" class="nowrap center hidden-phone"++>++

++<++?php echo JHtml::++_++('grid.sort', 'JGRID++_++HEADING++_++ID',
'id', $listDirn, $listOrder); ?++>++

++<++/th++>++

++<++/tr++>++

Dieses Template generiert mittels JHtml::++_++(...) die jeweiligen
Kopfzeilen der Liste, wobei diese entweder eine Checkbox-Funktion
(grid.checkall) oder eine Sortierfunktion (grid.sort) haben

Nun folgt der Footer in der Datei
_/admin/views/jobs/tmpl/default++_++foot.php_ (siehe Listing 17.24).

LISTING 17.24 Listenfooter _default++_++foot.php_

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted Access');

?++>++

++<++tr++>++

++<++td colspan="3"++><++?php echo
$this-++>++pagination-++>++getListFooter(); ?++><++/td++>++

++<++/tr++>++

Hier nutzen wir das in der View übergebene pagination-Objekt, um mit der
getListFooter()-Methode die Blättern-Funktion auszugeben.

Und was fehlt jetzt noch? Richtig, der Body unserer Liste, der die
einzelnen Listeneinträge enthält und in der Datei
_/admin/views/jobs/tmpl/default++_++body.php_ abgelegt wird.

LISTING 17.25 Listenbody default++_++body.php

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

// No direct access to this file

defined('++_++JEXEC') or die('Restricted Access');

$user = JFactory::getUser();

?++>++

++<++?php foreach ($this-++>++items as $i =++>++ $item):

$canEdit = $user-++>++authorise('core.edit', 'com++_++jobs.category.' .
$item-++>++catid);

?++>++

++<++tr class="row++<++?php echo $i % 2; ?++>++"++>++

++<++td class="center hidden-phone"++>++

++<++?php echo JHtml::++_++('grid.id', $i, $item-++>++id); ?++>++

++<++/td++>++

++<++td class="nowrap has-context"++>++

++<++?php if ($canEdit): ?++>++

++<++a href="++<++?php echo
JRoute::++_++('index.php?option=com++_++jobs&task=job.edit&id='.(int)
$item-++>++id); ?++>++"++>++

++<++?php echo $this-++>++escape($item-++>++title); ?++><++/a++>++

++<++?php else: ?++>++

++<++?php echo $this-++>++escape($item-++>++title); ?++>++

++<++?php endif; ?++>++

++<++/td++>++

++<++td class="center hidden-phone"++>++

++<++?php echo (int) $item-++>++id; ?++>++

++<++/td++>++

++<++/tr++>++

++<++?php endforeach; ?++>++

Hier geben wir in einer foreach-Schleife unsere Listeneinträge aus, die
wir zuvor in der View zugewiesen haben. Der JHTML::++_++-Aufruf in der
ersten Spalte gibt eine Checkbox zur Selektion der Einträge aus, die wir
zum Editieren oder Löschen eines Eintrags benötigen, die zweite Spalte
zeigt, falls durch das Rechtemanagement erlaubt, einen Bearbeitungs-Link

Damit ist unsere Listenansicht nun komplett.

Nun geht es mit der Formularansicht weiter, wobei wir auch hier mit dem
Anlegen einer View starten. Diese View, die in Listing 17.26 abgebildet
ist, wird in der Datei _/admin/views/job/view.html.php_ gespeichert.

LISTING 17.26 Formular-View

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Job View

++*++

++*++ @since 0.0.1

++*++/

class JobsViewJob extends JViewLegacy

++{++

protected $state;

protected $item;

protected $form;

/++**++

++*++ display method of Job view

++*++

++*++ @param string $tpl template name

++*++

++*++ @return void

++*++/

public function display($tpl = null)

++{++

// Get the Data

$this-++>++form = $this-++>++get('Form');

$this-++>++item = $this-++>++get('Item');

$this-++>++state = $this-++>++get('State');

// Check for errors.

if (count($errors = $this-++>++get('Errors')))

++{++

throw new RuntimeException(implode('++<++br /++>++', $errors), 500);

}

// Set the toolbar

$this-++>++addToolBar();

// Add CSS for icon

JFactory::getDocument()-++>++addStyleDeclaration('.icon-jobs
++{++background:url(../media/com++_++jobs/images/jobs-16x16.png)}');

// Display the template

parent::display($tpl);

}

/++**++

++*++ Setting the toolbar

++*++

++*++ @return void

++*++/

protected function addToolBar()

++{++

JFactory::getApplication()-++>++input-++>++set('hidemainmenu', true);

$user = JFactory::getUser();

$isNew = $this-++>++item-++>++id == 0;

$canDo = JHelperContent::getActions('com++_++jobs', 'category',
$this-++>++item-++>++catid);

JToolBarHelper::title($isNew ?
JText::++_++('COM++_++JOBS++_++MANAGER++_++JOB++_++NEW') :
JText::++_++('COM++_++JOBS++_++MANAGER++_++JOB++_++EDIT'), 'jobs');

// If not checked out, can save the item.

if
($canDo-++>++get('core.edit')++||++(count($user-++>++getAuthorisedCategories('com++_++jobs',
'core.create'))))

++{++

JToolbarHelper::apply('job.apply');

JToolbarHelper::save('job.save');

}

if (count($user-++>++getAuthorisedCategories('com++_++jobs',
'core.create')))

++{++

JToolbarHelper::save2new('job.save2new');

}

// If an existing item, can save to a copy.

if (!$isNew && (count($user-++>++getAuthorisedCategories('com++_++jobs',
'core.create')) ++>++ 0))

++{++

JToolbarHelper::save2copy('job.save2copy');

}

JToolbarHelper::cancel('job.cancel');

}

}

Diese _View_ ist ein wenig komplexer als die _View_ zur Generierung der
Listenansicht, aber bei genauer Betrachtung ist der Aufbau sehr logisch.
Die display()-Methode ist im Aufbau identisch zur Jobs-View, ruft aber
dieses Mal nicht die Listeneinträge des Jobs-_Model_, sondern das
Formular-Objekt ($this-++>++get('Form')) des zu editierenden Inhalts
($this-++>++get(Item)) sowie unseren State ($this-++>++get('State')) ab
und weist diese zur Verwendung im Template zu.

Spannender wird es in der Methode addToolBar, da wir eine jeweils leicht
veränderte Toolbar erzeugen müssen, wenn wir einen Eintrag erstellen
(_Speichern_, _Speichern & Schließen_, _Speichern & Neu_, _Abbrechen_)
oder einen bestehenden Eintrag bearbeiten (_Speichern_, _Speichern &
Schließen_, _Speichern & Neu_, _Als Kopie speichern_, _Abbrechen_). Um
diese Differenzierung vorzunehmen, prüfen wir, ob ein Eintrag geladen
wurde, der bereits eine ID hat. Daraus folgt, dass wir einen
existierenden Eintrag editieren wollen: $isNew = $this-++>++item-++>++id
== 0;. In den nachfolgenden If-Verzweigung wird die jeweilige Toolbar
unter Berücksichtigung der Berechtigungen für beide Fälle generiert.
Zudem blenden wir am Beginn der Methode das Administrationsmenü aus
(set('hidemainmenu', true)), um unsere Nutzer dazu zu zwingen, unsere
vorgesehenen Toolbar-Buttons zu nutzen.

Nun kommen wir zum Herzstück des Formulars: dem Template. Dieses wird
vom System standardmäßig in der Datei _/admin/views/job/tmpl/edit.php_
gesucht und ist in Listing 17.27 abgebildet.

LISTING 17.27 Formular-Template edit.php

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

defined('++_++JEXEC') or die('Restricted access');

JHtml::++_++('behavior.tooltip');

JHtml::++_++('behavior.formvalidation');

JFactory::getDocument()-++>++addScriptDeclaration("

Joomla.submitbutton = function(task)

++{++

if (task == 'job.cancel' ++||++
document.formvalidator.isValid(document.getElementById('job-form')))
++{++

" . $this-++>++form-++>++getField('description')-++>++save() . "

Joomla.submitform(task, document.getElementById('job-form'));

}

};

");

$params = $this-++>++form-++>++getFieldsets('params');

?++>++

++<++form action="++<++?php echo
JRoute::++_++('index.php?option=com++_++jobs&layout=edit&id=' . (int)
$this-++>++item-++>++id); ?++>++" method="post" name="adminForm"
id="job-form" class="form-validate"++>++

++<++?php echo JLayoutHelper::render('joomla.edit.title++_++alias',
$this); ?++>++

++<++div class="form-horizontal"++>++

++<++?php echo JHtml::++_++('bootstrap.startTabSet', 'myTab',
array('active' =++>++ 'details')); ?++>++

++<++?php echo JHtml::++_++('bootstrap.addTab', 'myTab', 'details',
JText::++_++('COM++_++JOBS++_++JOB++_++DETAILS', true)); ?++>++

++<++?php echo $this-++>++form-++>++getControlGroup('catid'); ?++>++

++<++?php echo $this-++>++form-++>++getControlGroup('description');
?++>++

++<++?php echo JHtml::++_++('bootstrap.endTab'); ?++>++

++<++?php echo JHtml::++_++('bootstrap.addTab', 'myTab', 'params',
JText::++_++('COM++_++JOBS++_++JOB++_++PARAMS', true)); ?++>++

++<++?php foreach ($this-++>++form-++>++getGroup('params') as $field) :
?++>++

++<++?php echo $field-++>++getControlGroup(); ?++>++

++<++?php endforeach; ?++>++

++<++?php echo JHtml::++_++('bootstrap.endTabSet'); ?++>++

++<++/div++>++

++<++input type="hidden" name="task" value="" /++>++

++<++?php echo JHtml::++_++('form.token'); ?++>++

++<++/form++>++

Das Editierungsformular nutzt die beiden JavaScript-Bibliotheken zur
Erzeugung von Tooltipps und zur clientseitigen Validierung, die wir vor
der Nutzung durch den Aufruf der entsprechenden Methoden der
JHtml-Klasse (JHtml::++_++('behavior.tooltip'),
JHtml::++_++('behavior.formvalidation')) laden müssen.

Das Formular wird anschließend durch einen ++<++form++>++-Tag
umschlossen, dessen action-Attribut wir durch die Angabe der ID unseres
Eintrags ergänzen (&id='.(int) $this-++>++item-++>++id). Anschließend
definieren wir durch die Nutzung der Tabbing-Funktion von JHtml zwei
Tabs, wobei der erste Tab das Auswahlfeld für die Kategorie und das
Eingabefeld für den Beschreibungstext enthält (++<++?php echo
$this-++>++form-++>++getControlGroup('catid'); ?++>++). Der zweite Tabs
lädt über eine foreach-Schleife alle Parameter der jeweiligen
Feldgruppe, die wir in unserem XML definiert haben.

===== Anlegen des Konfigurationsdialogs

Nun sind die Grundfunktionen des _Backends_ beinahe vollendet. Wir sind
jetzt in der Lage, Einträge anzuzeigen und zu bearbeiten. Was noch
fehlt, ist eine Funktion zur Editierung der Komponenten-Einstellungen,
die über das entsprechende Toolbar-Icon aufgerufen werden kann. Die
_API_ erleichtert uns hier ganz enorm die Arbeit, da wir nur das
entsprechende Toolbar-Icon hinzufügen und eine Datei namens _config.xml_
im Backend-Verzeichnis der Komponente anlegen müssen. Diese Datei, die
wir im Verzeichnis _/admin_ anlegen, ist in Listing 17.32 abgebildet.

LISTING 17.28 config.xml

++<++?xml version="1.0" encoding="utf-8"?++>++

++<++config++>++

++<++fieldset

name="title"

label="COM++_++JOBS++_++CONFIG++_++TITLE++_++SETTINGS++_++LABEL"

description="COM++_++JOBS++_++CONFIG++_++TITLE++_++SETTINGS++_++DESC"

++>++

++<++field

name="show++_++title"

type="radio"

label="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++TITLE++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++TITLE++_++DESC"

default="1"

++>++

++<++option value="0"++>++JHIDE++<++/option++>++

++<++option value="1"++>++JSHOW++<++/option++>++

++<++/field++>++

++<++field

name="show++_++category"

type="radio"

label="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++CATEGORY++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++CATEGORY++_++DESC"

default="0"

++>++

++<++option value="0"++>++JHIDE++<++/option++>++

++<++option value="1"++>++JSHOW++<++/option++>++

++<++/field++>++

++<++/fieldset++>++

++<++fieldset

name="permissions"

label="JCONFIG++_++PERMISSIONS++_++LABEL"

description="JCONFIG++_++PERMISSIONS++_++DESC"

++>++

++<++field

name="rules"

type="rules"

label="JCONFIG++_++PERMISSIONS++_++LABEL"

class="inputbox"

validate="rules"

filter="rules"

component="com++_++jobs"

section="component"

/++>++

++<++/fieldset++>++

++<++/config++>++

Diese Datei folgt der bereits bekannten XML-Struktur für
JForm-Definitionen und bildet hier, neben den bereits bekannten
Parametern zum Ausblenden des Titels oder der Kategorie eines
Job-Angebots, ein Feld vom Typ rules, das zur Steuerung der
Rechtevergabe unserer Komponente genutzt wird. Damit das JForm-Objekt
weiß, welche Rechte überhaupt zu vergeben sind, legen wir im _/admin_
Verzeichnis eine Datei namens _access.xml_ an, in der wir die möglichen
Aktionen unserer Erweiterung ablegen (siehe Listing 17.29).

LISTING 17.29 access.xml

++<++?xml version="1.0" encoding="utf-8" ?++>++

++<++access component="com++_++jobs"++>++

++<++section name="component"++>++

++<++action name="core.admin" title="JACTION++_++ADMIN"
description="JACTION++_++ADMIN++_++COMPONENT++_++DESC" /++>++

++<++action name="core.manage" title="JACTION++_++MANAGE"
description="JACTION++_++MANAGE++_++COMPONENT++_++DESC" /++>++

++<++action name="core.create" title="JACTION++_++CREATE"
description="JACTION++_++CREATE++_++COMPONENT++_++DESC" /++>++

++<++action name="core.delete" title="JACTION++_++DELETE"
description="JACTION++_++DELETE++_++COMPONENT++_++DESC" /++>++

++<++action name="core.edit" title="JACTION++_++EDIT"
description="JACTION++_++EDIT++_++COMPONENT++_++DESC" /++>++

++<++/section++>++

++<++/access++>++

Diese beiden Dateien reichen der _API_ zur automatischen Generierung der
Konfigurationsdialoge aus.

===== Anlegen der Helper-Klasse

Was fehlt jetzt noch? Richtig, die mysteriöse Helper-Klasse, die wir
bereits an einigen Stellen des Codes genutzt haben. Diese legen wir in
der Datei _/admin/helpers/jobs.php_ ab (siehe Listing 17.30).

LISTING 17.30 Jobs-Helper

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die;

/++**++

++*++ Class JobsHelper

++*++

++*++ @since 0.0.1

++*++/

abstract class JobsHelper

++{++

/++**++

++*++ Configure the Linkbar.

++*++

++*++ @param string $vName The name of the active view.

++*++

++*++ @return void

++*++/

public static function addSubmenu($vName = 'jobs')

++{++

JHtmlSidebar::addEntry(

JText::++_++('COM++_++JOBS++_++SUBMENU++_++MESSAGES'),

'index.php?option=com++_++jobs',

$vName == 'jobs'

);

JHtmlSidebar::addEntry(

JText::++_++('COM++_++JOBS++_++SUBMENU++_++CATEGORIES'),

'index.php?option=com++_++categories&extension=com++_++jobs',

$vName == 'categories'

);

}

}

Diese Klasse enthält die Methode addSubmenu die, wer hätte dies gedacht,
zur Generierung des komponenteneigenen Submenüs genutzt wird.

==== Anlegen der Backend-Sprachdateien

Nun kümmern wir uns um die sprachlichen Fähigkeiten unserer neuen
_Komponente_. Diese nutzt zur Ausgabe von Texten aller Art die Methode
JText::++_++(SPRACHSTRING), wobei wir bisher noch keine Übersetzungen
für diese _Sprachstrings_ angelegt haben. Dies holen wir in den
_Sprachdateien_ der Erweiterung nach, wobei Joomla! zwei Arten von
_Sprachdateien_ unterscheidet:

* _Komponenten-Sprachdateien_ werden nur dann geladen, wenn die
jeweilige Komponente gerade aktiv ist.
* _System-Sprachdateien_ werden bei jedem Seitenaufruf geladen, auch
ohne dass wir uns in der jeweiligen _Komponente_ befinden, die diese
_System-Sprachdatei_ mitbringt.

Dieser Umstand ist nützlich, wenn wir uns beispielsweise daran erinnern,
dass wir unseren Menüeintrag im Backend mit dem _Sprachstring_
COM++_++JOBS benannt haben. Wenn dieser _String_ in der
_Komponenten-Sprachdatei_ abgelegt wäre, würde uns der übersetzte
Menüeintrag nur dann angezeigt, wenn wir uns in der Komponente befinden.
Dadurch, dass wir diesen _Sprachstring_ in eine _System-Sprachdatei_
auslagern, wird stets die korrekte Übersetzung des Menüeintrags
angezeigt.

Fazit: Wir brauchen beide _Sprachdateien_ zur korrekten Anzeige unserer
_Komponente_ und beginnen mit der _System-Sprachdatei_, die wir unter
dem Namen _de-DE.com++_++jobs.sys.ini_ im Ordner
_/admin/language/de-DE/_ ablegen (siehe Listing 17.31). Achten Sie
darauf, dass Sie diese Dateien unbedingt UTF-8-kodiert abspeichern, da
es andernfalls zu Anzeigeschwierigkeiten kommen wird.

LISTING 17.31 System-Sprachdatei

COM++_++JOBS="Jobsverwaltung"

COM++_++JOBS++_++DESCRIPTION="Dies ist die Jobsverwaltung"

COM++_++JOBS++_++JOB++_++VIEW++_++DEFAULT++_++DESC="Diese Ansicht zeigt
ein Jobangebot an"

COM++_++JOBS++_++JOB++_++VIEW++_++DEFAULT++_++TITLE="Jobangebot"

COM++_++JOBS++_++INSTALL++_++TEXT="Jobs - Installations Skript"

COM++_++JOBS++_++MENU="Jobsverwaltung"

COM++_++JOBS++_++POSTFLIGHT++_++DISCOVER++_++INSTALL++_++TEXT="Jobs -
Nach-Installationsprüfung bei Discover Installation"

COM++_++JOBS++_++POSTFLIGHT++_++INSTALL++_++TEXT="Jobs -
Nach-Installationsprüfung bei Installation"

COM++_++JOBS++_++POSTFLIGHT++_++UNINSTALL++_++TEXT="Jobs -
Nach-Installationsprüfung bei Deinstallation"

COM++_++JOBS++_++POSTFLIGHT++_++UPDATE++_++TEXT="Jobs -
Nach-Installationsprüfung bei Update"

COM++_++JOBS++_++PREFLIGHT++_++DISCOVER++_++INSTALL++_++TEXT="Jobs -
Vor-Installationsprüfung bei Discover Installation"

COM++_++JOBS++_++PREFLIGHT++_++INSTALL++_++TEXT="Jobs -
Vor-Installationsprüfung bei Installation"

COM++_++JOBS++_++PREFLIGHT++_++UNINSTALL++_++TEXT="Jobs -
Vor-Installationsprüfung bei Deinstallation"

COM++_++JOBS++_++PREFLIGHT++_++UPDATE++_++TEXT="Jobs -
Vor-Installationsprüfung bei Update"

COM++_++JOBS++_++UNINSTALL++_++TEXT="Jobs - Deinstallations Skript"

COM++_++JOBS++_++UPDATE++_++TEXT="Jobs - Update Skript"

In dieser _Sprachdatei_ hinterlegen wir also, neben dem Namen und der
Beschreibung der Erweiterung, die Übersetzung des Menüpunkts, der
Installationsausgaben und der Beschreibungen unserer _View_.

Die _Komponenten-Sprachdatei_ wird im selben Ordner abgelegt und heißt
_de-DE.com++_++jobs.ini_ – Sie finden diese in Listing 17.32.

LISTING 17.32 Komponenten-Sprachdatei im Backend

COM++_++JOBS="Jobverwaltung"

COM++_++JOBS++_++ADMINISTRATION="Jobs - Administration"

COM++_++JOBS++_++ADMINISTRATION++_++CATEGORIES="Jobs - Kategorien"

COM++_++JOBS++_++JOB++_++CREATING="Job - Hinzufügen"

COM++_++JOBS++_++JOB++_++DETAILS="Details"

COM++_++JOBS++_++JOB++_++PARAMS="Parameter"

COM++_++JOBS++_++JOB++_++EDITING="Job - Bearbeiten"

COM++_++JOBS++_++JOB++_++ERROR++_++UNACCEPTABLE="Bitte prüfen Sie ihre
Eingaben"

COM++_++JOBS++_++JOB++_++FIELD++_++CATID++_++DESC="Die Kategorie des
Jobangebots"

COM++_++JOBS++_++JOB++_++FIELD++_++CATID++_++LABEL="Kategorie"

COM++_++JOBS++_++JOB++_++FIELD++_++TITLE++_++DESC="Titel des Jobangebot"

COM++_++JOBS++_++JOB++_++FIELD++_++TITLE++_++LABEL="Titel"

COM++_++JOBS++_++JOB++_++FIELD++_++DESCRIPTION++_++DESC="Beschreibung
des Jobangebot"

COM++_++JOBS++_++JOB++_++FIELD++_++DESCRIPTION++_++LABEL="Beschreibung"

COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++TITLE++_++LABEL="Zeige
Titel"

COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++TITLE++_++DESC="Zeigt den
Titel des jeweiligen Jobangebots."

COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++CATEGORY++_++LABEL="Zeige
Kategorie"

COM++_++JOBS++_++JOB++_++FIELD++_++SHOW++_++CATEGORY++_++DESC="Zeigt die
Kategorie des jeweiligen Jobangebots."

COM++_++JOBS++_++JOB++_++HEADING++_++TITLE="Titel"

COM++_++JOBS++_++JOB++_++HEADING++_++ID="ID"

COM++_++JOBS++_++MANAGER++_++JOB++_++EDIT="Jobs Manager: Bearbeite Job"

COM++_++JOBS++_++MANAGER++_++JOB++_++NEW="Jobs Manager: Neuen Job"

COM++_++JOBS++_++MANAGER++_++JOBS="Jobs Manager"

COM++_++JOBS++_++N++_++ITEMS++_++DELETED++_++1="Einen Job gelöscht"

COM++_++JOBS++_++N++_++ITEMS++_++DELETED++_++MORE="%d Jobs gelöscht"

COM++_++JOBS++_++SUBMENU++_++MESSAGES="Jobs"

COM++_++JOBS++_++SUBMENU++_++CATEGORIES="Kategorien"

COM++_++JOBS++_++CONFIGURATION="Jobs Konfiguration"

COM++_++JOBS++_++CONFIG++_++TITLE++_++SETTINGS++_++LABEL="Job
Einstellungen"

COM++_++JOBS++_++CONFIG++_++TITLE++_++SETTINGS++_++DESC="Einstellungen,
welche standardmäßig auf alle Jobs angewendet werden"

In dieser Datei hinterlegen wir alle übrigen _Sprachstrings_, die wir in
unserer _Komponente_ verwendet haben.

==== Anlegen der benötigten Medien-Dateien

Nun fehlt uns nur noch ein schickes Icon zur Verwendung in der Toolbar ,
das wir bereits in Form eines CSS-Statements in der View.html.php
unserer Erweiterung angegeben haben. Suchen Sie sich dazu einfach zwei
passende Icons, die Sie in der Größe 16 x 16 Pixel unter dem Namen
_jobs-16x16.png_ im Ordner _/book/17-erweiterungen-erstellen/media/s/_ unserer Komponente ablegen.
Et voilà! Fertig ist das Backend!

image:book/17-erweiterungen-erstellen/media/5.png[book/17-erweiterungen-erstellen/media/5,width=548,height=189]

BILD 17.3 Eintragsübersicht im Backend

image:book/17-erweiterungen-erstellen/media/7.png[book/17-erweiterungen-erstellen/media/7,width=548,height=353]

BILD 17.4 Formular zur Bearbeitung eines Jobangebots

==== Anlegen des MVC-Patterns im Frontend

===== Anlegen des Dispatchers

Nun kümmern wir uns um das Frontend unserer Erweiterung. Hier beginnen
wir erneut mit dem _Dispatcher_, den wir unter dem Namen _jobs.php_ im
Verzeichnis _/site_ ablegen (siehe Listing 17.31).

LISTING 17.31 Frontend-Dispatcher

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

// Get an instance of the controller prefixed by HelloWorld

$controller = JControllerLegacy::getInstance('Jobs');

// Perform the Request task

$controller-++>++execute(JFactory::getApplication()-++>++input-++>++get('task',
'', 'CMD'));

// Redirect if set by the controller

$controller-++>++redirect();

Dieser Dispatcher entspricht in weiten Teilen dem _Backend-Dispatcher_,
wobei hier die Rechteprüfung und die Einbindung des _Helpers_ entfallen.

===== Anlegen des Controllers

Den _Controller_ des _Frontends_ leiten wir von der Klasse
JControllerLegacy ab, die keine weitere Modifikationen erfordert – denn
anders als im Backend geht es uns hier um die reine Anzeige eines
Jobangebots, wofür wir auf die bereits vordefinierte display-Methode
zurückgreifen können (siehe Listing 17.32).

LISTING 17.32 Frontend-Controller

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Jobs Component Controller

++*++

++*++ @since 0.0.1

++*++/

class JobsController extends JControllerLegacy

++{++

}

===== Anlegen des Models

Nun müssen wir noch ein entsprechendes _Model_ anlegen, welches das in
den Parametern des jeweiligen Menüeintrags angegebene Jobangebot abruft
und anzeigt. Dieses _Model_ leiten wir von der Klasse JModelItem ab, die
vom System für den Abruf eines einzelnen Eintrags vorgesehen ist. Sie
finden dieses Model in Listing 17.33 und speichern es unter dem Namen
_job.php_ im Ordner _/site/models_.

LISTING 17.33 Frontend-Model

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

/++**++

++*++ Job Model

++*++

++*++ @since 1.0.0

++*++/

class JobsModelJob extends JModelItem

++{++

protected $item;

/++**++

++*++ populate internal state

++*++

++*++ @return void

++*++/

protected function populateState()

++{++

$app = JFactory::getApplication();

// Get the job id

$id = $app-++>++input-++>++get('id', '', 'INT');

$this-++>++setState('job.id', $id);

// Load the parameters.

$params = $app-++>++getParams();

$this-++>++setState('params', $params);

parent::populateState();

}

/++**++

++*++ Returns a reference to the a Table object, always creating it.

++*++

++*++ @param string $type The table type to instantiate

++*++ @param string $prefix A prefix for the table class name. Optional.

++*++ @param array $config Configuration array for table. Optional.

++*++

++*++ @return JTable A database object

++*++/

public function getTable($type = 'Jobs', $prefix = 'JobsTable', $config
= array())

++{++

return JTable::getInstance($type, $prefix, $config);

}

/++**++

++*++ Get the job

++*++

++*++ @return object The job to be displayed to the user

++*++/

public function getItem()

++{++

if (!isset($this-++>++item))

++{++

$db = JFactory::getDbo();

$id = $this-++>++getState('job.id');

$query = $db-++>++getQuery(true)-++>++from('#++__++jobs as j')

-++>++leftJoin('#++__++categories as c ON j.catid=c.id')

-++>++select('j.title AS title, j.params, j.description, c.title as
category')

-++>++where('j.id=' . (int) $id);

$db-++>++setQuery($query);

$this-++>++item = $db-++>++loadObject();

// Load the JSON encoded params

$params = new ++\++Joomla++\++Registry++\++Registry;

$params-++>++loadString($this-++>++item-++>++params, 'JSON');

$this-++>++item-++>++params = $params;

// Merge global params with item params

$params = clone $this-++>++getState('params');

$params-++>++merge($this-++>++item-++>++params);

$this-++>++item-++>++params = $params;

}

return $this-++>++item;

}

}

Dieses Model implementiert drei verschiedene Methoden, wobei wir die
Methode get­Table bereits aus dem _Backend-Model_ kennen.

Die Methode populateState wird bei der Initialisierung des Models
aufgerufen und legt die ID des anzuzeigenden Jobangebots sowie die
allgemeinen Parameter der Erweiterung in den sog. _Model-States_ ab.
Diese States können anschließend an verschiedenen Stellen des Models
abgefragt werden, wodurch wir uns andernfalls redundanten Code ersparen
können.

Die Methode getItem dient zum eigentlichen Abruf unseres Jobangebots aus
der Datenbank, wofür wir erneut die Klasse JDatabaseQuery nutzen. Wenn
das Angebot erfolgreich geladen ist, müssen wir allerdings noch die
globalen Parameter der Erweiterung mit den Parametern des einzelnen
Eintrags abgleichen, was durch die Nutzung der Methode
$params-++>++merge() geschieht.

===== Anlegen der View

Das _Model_ ist damit vollendet, sodass wir uns der Anzeige des Angebots
widmen können. Zu diesem Zwecke legen wir die Datei _view.html.php_ im
Ordner _/site/views/job_ an, deren Code in Listing 17.34 abgebildet ist.

LISTING 17.34 Frontend-View

++<++?php

/++**++

++*++ @package ComJobs

++*++ @copyright 2017 David Jardin

++*++ @license GNU GPLv2 ++<++http://www.gnu.org/licenses/gpl.html++>++

++*++ @link http://www.djumla.de

++*++/

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

// Import Joomla view library

jimport('joomla.application.component.view');

/++**++

++*++ HTML View class for the Jobs Component

++*++

++*++ @since 0.0.1

++*++/

class JobsViewJob extends JViewLegacy

++{++

/++**++

++*++ Display job item

++*++

++*++ @param string $tpl template name

++*++

++*++ @return void

++*++/

public function display($tpl = null)

++{++

// Assign data to the view

$this-++>++item = $this-++>++get('Item');

// Check for errors.

if (count($errors = $this-++>++get('Errors')))

++{++

throw new RuntimeException(implode('++<++br /++>++', $errors), 500);

}

// Display the view

parent::display($tpl);

}

}

Auch diese View ist von der bereits bekannten Klasse JViewLegacy
abgeleitet und überschreibt die ebenfalls bekannte display-Methode. In
ihr wird die im Model definierte getItem-Methode abgerufen und das
Ergebnis dieser Abfrage mittels $this-++>++item = $this-++>++get('Item')
an das _Template_ übergeben.

Dieses _Template_ wird unter dem bekannten Standardnamen _default.php_
im Verzeichnis _/site/views/job/tmpl_ abgelegt und ist in Listing 17.35
abgebildet.

LISTING 17.35 Frontend-Template

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die('Restricted access');

?++>++

++<++?php if($this-++>++item-++>++params-++>++get('show++_++title')):
?++>++

++<++h1++>++

++<++?php echo
$this-++>++item-++>++title.(($this-++>++item-++>++params-++>++get('show++_++category'))
? (' ('.$this-++>++item-++>++category.')') : ''); ?++>++

++<++/h1++>++

++<++?php endif; ?++>++

++<++?php echo $this-++>++item-++>++description ?++>++

Das _Template_ prüft die Parameter des Eintrags
($this-++>++item-++>++params) und zeigt, falls gewünscht, den Titel bzw.
die Kategorie des jeweiligen Eintrags an. Zudem geben wir die
Beschreibung des jeweiligen Jobangebots aus.

Wenn wir unser _Layout_ (Anzeige-Template der Erweiterung) nun in das
Menü unserer Seite einbinden wollen, ergibt sich noch ein letztes
Problem: Wir haben derzeit noch keine Möglichkeit auszuwählen, welches
Jobangebot beim Aufruf dieses Eintrags angezeigt werden soll, weil die
_Parameter_ des Menüeintrags noch nicht definiert sind. Joomla!
erwartet, dass die Parameter eines bestimmten _Layouts_ in einem
XML-Dokument hinterlegt sind, das sich ebenfalls im Ordner
_/site/views/job/tmpl_ befindet und den Namen des entsprechenden
_Templates_, also _default.xml_, trägt (siehe Listing 17.36).

LISTING 17.36 Parameter des Frontend-Layouts

++<++?xml version="1.0" encoding="utf-8"?++>++

++<++metadata++>++

++<++layout
title="COM++_++JOBS++_++JOB++_++VIEW++_++DEFAULT++_++TITLE"++>++

++<++message++>++COM++_++JOBS++_++JOB++_++VIEW++_++DEFAULT++_++DESC++<++/message++>++

++<++/layout++>++

++<++fields

name="request"

addfieldpath="/administrator/components/com++_++jobs/models/fields"

++>++

++<++fieldset name="request"++>++

++<++field

name="id"

type="job"

label="COM++_++JOBS++_++JOB++_++FIELD++_++TITLE++_++LABEL"

description="COM++_++JOBS++_++JOB++_++FIELD++_++TITLE++_++DESC"

/++>++

++<++/fieldset++>++

++<++/fields++>++

++<++/metadata++>++

In diesem XML-Dokument definieren wir zum einen den Titel
(++<++title++>++) sowie die Beschreibung (++<++message++>++) des
jeweiligen Layouts. Zum anderen können wir Parameter im request-Fieldset
definieren, die beim Aufruf der jeweiligen Seite an die Nutzeranfrage
(also in unserem Fall die URL der Seite) angehangen werden, wodurch wir
die id des jeweiligen anzuzeigenden Jobangebots abrufen können. Als type
für diesen Parameter geben wir unseren eigenen Parameter-Typ job an, den
wir noch separat definieren müssen. Dafür legen wir eine Datei namens
_job.php_ im Verzeichnis _/admin/models/fields_ ab, deren Code in
Listing 17.37 abgebildet ist.

LISTING 17.37 Selbst definiertes Formularfeld für die Auswahl des
Jobangebots

++<++?php

// No direct access to this file

defined('++_++JEXEC') or die;

JFormHelper::loadFieldClass('list');

/++**++

++*++ Job Form Field class for the Jobs component

++*++

++*++ @since 0.0.1

++*++/

class JFormFieldJob extends JFormFieldList

++{++

/++**++

++*++ The field type.

++*++

++*++ @var string

++*++/

protected $type = 'Job';

/++**++

++*++ Method to get a list of options for a list input.

++*++

++*++ @return array An array of JHtml options.

++*++/

protected function getOptions()

++{++

$db = JFactory::getDBO();

$query = $db-++>++getQuery(true);

$query-++>++select('#++__++jobs.id as id, #++__++jobs.title as title,
#++__++categories.title as category,catid');

$query-++>++from('#++__++jobs');

$query-++>++leftJoin('#++__++categories on catid=#++__++categories.id');

$db-++>++setQuery((string) $query);

$jobs = $db-++>++loadObjectList();

$options = array();

if ($jobs)

++{++

foreach ($jobs as $job)

++{++

$options++[]++ = JHtml::++_++('select.option', $job-++>++id,
$job-++>++title . ($job-++>++catid ? ' (' . $job-++>++category . ')' :
''));

}

}

$options = array++_++merge(parent::getOptions(), $options);

return $options;

}

}

Da Joomla! zum Parsen des XML-Dokuments die bereits bekannte
JForm-Klasse nutzt, orientieren wir uns bei der Erstellung unserer
Parametertyps an den bereits vorhandenen Feldtypen und leiten unsere
Klasse daher von der allgemeinen Klasse zur Generierung von
Select-Listen (JFormFieldList) ab. In ihr überschreiben wir die
getOptions-Methode und rufen darin eine Liste aller vorhandenen
Jobangebote mit ihrer jeweiligen Kategorie ab. Die Generierung des
zugehörigen HTML-Codes wird dann von der Elternklasse JFormFieldList
übernommen.

==== Anlegen der Frontend-Sprachdateien

Nun müssen wir nur noch eine Frontend-Sprachdatei unter dem Namen
_de-DE.com++_++jobs.ini_ im Verzeichnis _/site/language/de-DE_ anlegen,
in der wir die deutsche Beschreibung der Komponente hinterlegen. Weitere
_Sprachstrings_ sind nicht notwendig, da wir im Frontend keine weiteren
Strings verwenden.

LISTING 17.38 Frontend-Sprachdatei

COM++_++JOBS="Jobverwaltung"

COM++_++JOBS++_++DESCRIPTION="Dies ist die Jobverwaltung"

==== Installieren der fertigen Erweiterung

Unsere erste eigene Erweiterung ist jetzt fertig programmiert und kann
installiert werden. Dazu reicht es, den gesamten Inhalt des
Erweiterungsverzeichnisses zu zippen und anschließend über den
Joomla!-eigenen Erweiterungsmanager einzuspielen.

=== Plug-ins entwickeln

Nachdem Sie nun die Grundzüge der Entwicklung eigener Erweiterungen
beherrschen, wollen wir uns mit der zweiten Disziplin in der
Joomla!-Entwicklung beschäftigen: der Modifizierung von bestehenden
Erweiterungen bzw. Core-Funktionen mittels _Plug-ins_.

Plug-ins sind die in meinen Augen am meisten verkannte Erweiterungsart
in der Joomla!-Welt, da sie die Beeinflussung des Verhaltens von nahezu
allen integrierten Erweiterungen und Funktionen erlauben, ohne dass
dafür Veränderungen am Quellcode der ursprünglichen Erweiterung (sog.
Corehacks) notwendig sind. Diese Corehacks sollten um jeden Preis
vermieden werden, da sie bei jedem Update der Joomla!-Installation bzw.
der jeweiligen Originalerweiterung erneut eingespielt werden müssten.
Das bringt einen unglaublich hohen Wartungsaufwand mit sich und
verleitet dazu, solche wichtigen Updates aus Faulheit einfach
auszulassen, wodurch jedoch leider auch wichtige
Sicherheitsverbesserungen nicht mit installiert werden.

Plug-ins hingegen erlauben die Modifizierung des Verhaltens einer
Erweiterung in einer separaten Funktion, die von der
Originalerweiterung, an der jeweiligen Stelle, aufgerufen wird.

==== Grundprinzip

Joomla! nutzt im API-eigenen Plug-in-System das sog. Observer-Pattern.
Diese in zahlreichen Frameworks genutzte Technik arbeitet mit drei
verschiedenen Bestandteilen: dem _Dispatcher_, dem _Observer_ und dem
_Subjekt_.

Die Rolle des _Observers_ (Beobachters) wird dabei vom jeweiligen
Plug-in eingenommen. Dieses Plug-in soll in unserem Beispiel beim
Anzeigen eines Beitrags einen „Weiterlesen“-Link generieren und
definiert dafür die Methode onContentDisplay().

Ist dieses Plug-in aktiv, so wird der _Dispatcher_ (Vermittler) des
Systems beim Aufruf der Seite die Methoden dieses Plug-ins auslesen und
dabei registrieren, dass die Methode onContentDisplay des Plug-ins
„Weiterlesen“ beim Aufruf des gleichnamigen _Events_ ausgeführt werden
soll.

Nun kommt das _Subjekt_ ins Spiel. Dieses _Subjekt_, in unserem Beispiel
die Beitragsverwaltung _com++_++content_, ruft an der entsprechenden
Stelle, nämlich beim Anzeigen eines Beitrags, das onContentDisplay-Event
des Dispatchers auf. Der _Dispatcher_ wiederum führt dann die
gleichnamige Methode in unserem _Plug-in_ aus und gibt das Ergebnis (den
Text mit Weiterlesen-Link) an das _Subjekt_ zurück (siehe Bild 17.5).

image:book/17-erweiterungen-erstellen/media/8.png[C:++\++Users++\++hwunder++\++Desktop++\++rtf++\++17++\++Bild3106.PNG,width=389,height=291]

BILD 17.5 Beispielimplementierung des _Observer_-Patterns

Der große Vorteil der Technik ist, dass wir an dieser Stelle eine
1:n-Relation erzeugen können – es ist also möglich, dass mehrere
_Observer_ (also _Plug-ins_) sich für ein _Event_ registrieren. Zudem
sind unsere Plug-ins nicht an ein bestimmtes _Subjekt_ gebunden, da die
Kommunikation stets über den _Dispatcher_ erfolgt.

Eine Besonderheit der Joomla!-eigenen Implementierung des
_Observer_-Patterns ist, dass Joomla! die _Events_ (und damit auch die
zugehörigen _Plug-ins_) in bestimmte Gruppen einteilt, um eine gewisse
Übersichtlichkeit zu gewährleisten.

==== Beispiel-Plug-in

Gestalten wir die ganze Angelegenheit nun etwas plastischer. Stellen Sie
sich vor, wir wollten ein Plug-in schreiben, das beim Aufrufen eines
Beitrags die Zeile „Sie betrachten diesen Inhalt am
++[++Datumsangabe++]++“ einfügt. Dazu legen wir an einem Ort unserer
Wahl einen Ordner _datedisplay_ an, in dem wir eine gleichnamige
XML-Datei (_datedisplay.xml_) ablegen. Diese Datei entspricht der
bereits bekannten Syntax der XML-Dokumente, die zur Beschreibung einer
Joomla!-Erweiterung genutzt werden (siehe Listing 17.38).

LISTING 17.38 datedisplay.xml

++<++?xml version="1.0" encoding="utf-8"?++>++

++<++extension version="3.7" type="plugin" group="content"++>++

++<++name++>++Date-Display++<++/name++>++

++<++author++>++David Jardin++<++/author++>++

++<++creationDate++>++March 2017++<++/creationDate++>++

++<++copyright++>++Copyright (C) 2017 David Jardin. All rights
reserved.­++<++/copyright++>++

++<++license++>++GNU General Public License version 2 or later; see
LICENSE.txt++<++/license++>++

++<++authorEmail++>++info@djumla.de++<++/authorEmail++>++

++<++authorUrl++>++www.djumla.de++<++/authorUrl++>++

++<++version++>++1.0.0++<++/version++>++

++<++description++>++Zeigt das aktuelle Abrufdatum des Beitrags
an++<++/description++>++

++<++files++>++

++<++filename
plugin="datedisplay"++>++datedisplay.php++<++/filename++>++

++<++/files++>++

++<++/extension++>++

Dieses XML-Dokument weist, im Vergleich zu den XML-Dokumenten für
Komponenten, zwei Besonderheiten auf: Zum Ersten finden wir im
++<++extension++>++-Tag ein Attribut group, das die Gruppe angibt, der
das _Plug-in_ zugeordnet werden soll. Zum Zweiten benötigen wir für den
++<++filename++>++-Tag ein plugin-Attribut, das Joomla! mitteilt, wie
der interne Name des _Plug-ins_ lautet.

Nun müssen wir noch den eigentlichen Code unserer Plug-ins schreiben.
Dazu legen wir im bekannten Ordner die Datei _datedisplay.php_ an, die
in Listing 17.39 abgebildet ist.

LISTING 17.39 datedisplay.php

++<++?php

// No direct access.

defined('++_++JEXEC') or die;

class plgContentDatedisplay extends JPlugin

++{++

public function onContentPrepare($context, &$row, &$params, $page = 0)

++{++

$canProceed = $context == 'com++_++content.article';

if (!$canProceed) ++{++

return;

}

$date = JFactory::getDate();

$row-++>++text = "++<++p++>++Sie betrachten diesen Inhalt am "

. $date-++>++format("d.m.y") . "++<++/p++>++"

. $row-++>++text;

}

}

Im ersten Schritt leiten wir die Klasse unseres Plug-ins (die der
Namenskonvention _plgGruppennamePluginname_ entspricht) von der Klasse
JPlugin ab. Anschließend definieren wir die Methode onContentPrepare,
die beim Aufruf des gleichnamigen _Events_ gestartet wird. Die Methode
bekommt dabei den _Kontext_ (also das _Subjekt_, das das _Event_
gestartet hat), den jeweiligen Inhalt ($row) sowie die Parameter des
Inhalts und eine Angabe zur derzeitigen Seite übergeben. Nachdem wir uns
versichert haben, dass das Event wirklich beim Anzeigen eines einzelnen
Artikels aufgerufen wurde ($context == 'com++_++content.article'),
ergänzen wir den Text des Artikels um unsere gewünschte Datums­angabe.

Anschließend zippen wir diese beiden Dateien, laden Sie über den
Erweiterungsinstaller hoch und aktivieren das _Plug-in_. Nun wird uns
die gewünschte Datumsangabe angezeigt, ohne dass wir auch nur eine Zeile
Code des Joomla!-Kerns verändern mussten.

==== Verfügbare Plug-in-Events

Da es wenig Sinn macht, konkrete Anwendungsfälle für die Plug-ins
aufzulisten, möchte ich Ihnen stattdessen lieber eine Übersicht der
verfügbaren Events bieten. Basierend auf diesen Events sollte es Ihnen
möglich sein, die für Ihren Bedarf passende Schnittstelle zur
Modifizierung des Verhaltens der Originalerweiterung bzw. -funktion zu
finden.

TABELLE 17.11 Verfügbare _Plug-in-Events_ in Joomla! 3.7

[width="100%",cols="15%,26%,22%,37%",]
|===
|Gruppe |Event |Parameter |Beschreibung

|System |_onAfterInitialise_ |Keine |Wird unmittelbar nach dem
Initialisieren des Frameworks aufgerufen (Laden der benötigten Klassen,
des Nutzers und der Sprache)

| |_onAfterRoute_ |keine |Wird nach dem Parsen der Anfrage und
unmittelbar vor dem Laden der jeweiligen Komponente aufgerufen

| |_onAfterDispatch_ |keine |Wird nach dem Ausführen der jeweiligen
Komponenten aufgerufen

| |_onBeforeRender_ |keine |Wird vor dem Rendern des Templates
aufgerufen

| |_onAfterRender_ |keine |Wird nach dem Rendern des Templates
aufgerufen

| |_onBeforeExecute_ |keine |Wird (in selbst geschriebenen Applikationen
für die Joomla!-Plattform, siehe Kapitel 17.6) vor der Ausführung der
Applikation aufgerufen

| |_onAfterExecute_ |keine |Wird nach der Ausführung der jeweiligen
Applikation aufgerufen

| |_onBeforeRespond_ |keine |Wird in eigenen Applikationen vor dem
Absenden der Antwort an den Client aufgerufen

| |_onAfterRespond_ |keine |Wird in eigenen Applikationen nach dem
Senden der Antwort an den Browser aufgerufen

| |_onReceiveSignal_ |$signal |Wird aufgerufen, wenn eine
CLI-Applikation ein POSIX-Signal (SIGHUP, SIGTERMN) empfängt

| |_onBeforeCompileHead_ |Keine |Wird vom HTML-Renderer vor dem ­Parsen
des ++<++head++>++-Tags aufgerufen

| |_onAfterCleanModuleList_ |&$modules |Wird von JModuleHelper
aufgerufen, sobald die bereinigte Liste von Modulen für eine Abfrage
erstellt wurde

| |_onAfterCompress_ | |Wird vom Applikation Objekt aufgerufen, wenn
GZIP aktiviert ist

| |_onAfterGetMenuTypeOptions_ |&$list, $MenusModelMenutypes |Wird vom
Menutype Model aufgerufen und erlaubt das dynamische Hinzufügen von
Menütypen

| |_onAfterModuleList_ |&$modules |Wird von JModuleHelper aufgerufen,
sobald die Liste von Modulen für eine Abfrage erstellt wurde

| |_onAfterRenderModule_ |&$module, &$attribs |Wird nach dem Rendern
eines Moduls ausgerufen

| |_onAfterRenderModules_ |&$modules |Wird nach dem Rendern aller Module
aufgerufen

| |_onAfterSessionStart_ | |Wird nach dem Starten der Session aufgerufen

| |_onBeforeRenderMenuItems_ |$MenusViewItems |Wird vom Menutype Model
aufgerufen und erlaubt das dynamische Hinzufügen von Menütypen

| |_onBuildAdministratorLoginURL_ |&$uri |Wird vom
Update-Notification-Plugin aufgerufen, wenn dieses die
Administrations-URL generieren muss

| |_onGetStatsData_ |$context |Ruft die Statistikdaten ab, die an den
Statistikdienst des Projekts gesendet werden

| |_onPrepareModuleList_ |&$modules |Wird von JModuleHelper aufgerufen,
bevor die Liste der Module abgerufen wird

| |_onRenderModule_ |&$module, &$attribs |Wird vor dem dem Rendern eines
Modules augerufen

|Content |_onContentPrepareData_ |$context, $data |Wird beim Abrufen von
Einträgen (Beitrag, Weblink, Banner, Medien etc.) aufgerufen

| |_onContentBeforeSave_ |$context, $table, $isNew |Wird vor dem
Speichern eines Eintrags (Beitrag, Weblink, Banner, Modul etc.)
aufgerufen

| |_onContentAfterSave_ |$context, $table, $isNew |Wird nach dem
Speichern eines Eintrags aufgerufen

| |_onContentPrepare_ |$context, $item, $params, $offset |Wird beim
Abrufen des anzuzeigenden Beitrags aufgerufen

| |_onContentPrepareForm_ |$form, $data |Wird beim Laden eines Formulars
aufgerufen

| |_onContentChangeState_ |$context, $ids, $value |Wird aufgerufen, wenn
der Status der Einträge mit den übergebenen IDs verändert wird

| |_onContentBeforeDelete_ |$context, $data |Wird vor dem Löschen des
jeweiligen Eintrags aufgerufen

| |_onContentAfterDelete_ |$context, $data |Wird nach dem Löschen des
jeweiligen Eintrags aufgerufen

| |_onContentBeforeDisplay_ |$context, $item, $params, $offset |Wird vor
dem Ausgeben eines Beitrags aufgerufen

| |_onContentAfterDisplay_ |$context, $item, $params, $offset |Wird nach
dem Ausgeben eines Beitrags aufgerufen

| |_onContentAfterTitle_ |$context, $item, $params, $offset |Wird nach
dem Ausgeben des Beitragstitels aufgerufen

| |_onContentCleanCache_ |$options |Wird aufgerufen, wenn der
Joomla!-eigene Cache geleert wird

|Category |_onCategoryChangeState_ |$extension, $ids, $value |Wird
aufgerufen, wenn der Status einer Kategorie verändert wird

|User |_onUserBeforeDeleteGroup_ |$group |Wird vor dem Löschen einer
Nutzergruppe aufgerufen

| |_onUserAfterDeleteGroup_ |$group, true, $errors |Wird nach dem
Löschen einer Nutzergruppe aufgerufen

| |_onUserBeforeDelete_ |$user |Wird vor dem Löschen eines Benutzers
aufgerufen

| |_onUserAfterDelete_ |$user, $result, $errors |Wird nach dem Löschen
eines Benutzers aufgerufen

| |_onUserBeforeSave_ |$olduser, $isNew, $user |Wird vor dem Speichern
eines Benutzers aufgerufen

| |_onUserAfterSave_ |$user, $isNew, $result, $errors |Wird nach dem
Speichern eines Benutzers aufgerufen

| |_onUserAuthorisation_ |$response, $options |Wird aufgerufen, wenn
geprüft werden soll, ob ein Nutzer die Login-Funktion nutzen darf

| |_onUserAuthorisationFailure_ |$authorisation |Wird aufgerufen, wenn
ein Nutzer die Login-Funktion nicht nutzen darf

| |_onUserLogin_ |$response, $options |Wird aufgerufen, wenn sich ein
Nutzer erfolgreich einloggt

| |_onUserLoginFailure_ |$response |Wird aufgerufen, wenn sich ein
Nutzer nicht erfolgreich eingeloggt hat

| |_onUserLogout_ |$parameters |Wird aufgerufen, wenn ein Nutzer sich
abmeldet

| |_onUserLogoutFailure_ |$parameters |Wird aufgerufen, wenn ein Nutzer
nicht abgemeldet werden konnte

| |_onUserAfterLogin_ |$options |Wird nach dem Login eines Nutzers
aufgerufen

| |_onUserAfterLogout_ |$options |Wird nach dem Logout eines Nutzers
augerufen

| |_onUserAfterSaveGroup_ |$context, &$item |Wird aufgerufen, wenn eine
Benutzergruppe gespeichert wurde

| |_onUserBeforeDataValidation_ |$form, &$data |Wird aufgerufen, bevor
die Daten eines Nutzers gespeichert werden und die zugehörige
Validierung gestartet wurde

| |_onUserBeforeSaveGroup_ |$context, &$item |Wird vor dem Speichern
einer Nutzergruppe aufgerufen

|Contact |_onValidateContact_ |$contact, $data |Wird aufgerufen, wenn
ein Nutzer ein Kontaktformular ausgefüllt und abge­sendet hat und die
Eingaben validiert werden müssen

| |_onSubmitContact_ |$contact, $data |Wird aufgerufen, wenn ein Nutzer
ein Kontaktformular ausgefüllt und abgesendet hat und diese Nachricht
nun per Mail versendet wird

|Authentication |_onUserAuthenticate_ |$credentials, $options, $response
|Wird aufgerufen, wenn die Login-Daten eines Benutzers geprüft werden
sollen

|Search |_onContentSearch_ |$text, $phrase, $ordering, $areas |Wird
aufgerufen, wenn ein Suchbegriff mit der Standard-Suchfunktion gesucht
wird

| |_onContentSearchAreas_ |keine |Wird aufgerufen, um eine Liste aller
Seitenbereiche für die Suchfunktion zu erstellen

|Captcha |_onCheckAnswer_ |$code |Wird aufgerufen, um die eingegebene
Lösung des Nutzers zu validieren

| |_onDisplay_ |$name, $id, $class |Wird aufgerufen, wenn ein Captcha
ausgegeben werden soll

| |_onInit_ |$id |Wird aufgerufen, wenn ein Captcha verwendet werden
soll

|Finder |_onStartIndex_ |keine |Wird aufgerufen, wenn der Finder mit der
Indexierung startet

| |_onBeforeIndex_ |keine |Wird aufgerufen, bevor der Finder mit der
Indexierung startet

| |_onBuildIndex_ |keine |Wird aufgerufen, wenn der Finder mit der
Indexierung startet

| |_onStartUpdate_ |keine |Wird aufgerufen, wenn der Finder mit einem
Update des Indexes startet

| |_onBuildUpdate_ |keine |Wird aufgerufen, wenn der Finder das Update
verarbeitet

| |_onPrepareFinderContent_ |$item |Wird beim Indizieren eines Inhalts
aufgerufen und kann genutzt werden, um zugehörige Informationen für
einen Inhalt zum Suchindex hinzuzufügen

| |_onFinderAfterSave_ |$conext, $row, $isNew |Wird nach dem Speichern
eines Eintrags aufgerufen, um den Index des Finders zu aktualisieren

| |_onFinderBeforeSave_ |$context, $row, $isNew |Wird vor dem Speichern
eines Eintrags aufgerufen, um den Index des Finders zu aktualisieren

| |_onFinderAfterDelete_ |$context, $row |Wird aufgerufen, um nach dem
Löschen eines Eintrags den Index des Finders zu aktualisieren

| |_onFinderChangeState_ |$context, $row, $value |Wird aufgerufen, um
nach der Status­änderung eines Eintrags den Index des Finders zu
aktualisieren

| |_onFinderCategoryChangeState_ |$extension, $pks, $value |Wird
aufgerufen, um nach dem Ändern eines Kategorienstatus den Index des
Finders zu aktualisieren

|Quickicon |_onGetIcons_ |keine |Wird aufgerufen, wenn die Quick-Icons
im Control-Panel des Backends generiert werden sollen

|Editors |_onInit_ |keine |Wird zur Initialisierung eines Editors
aufgerufen

| |_onGetContent_ |$editor |Wird aufgerufen, um den Code zur Abfrage des
Editorinhalts zu generieren

| |_onSetContent_ |$editor, $html |Wird aufgerufen, um den Code zum
Setzen des Editorinhalts zu generieren

|Editors |_onSave_ |$editor |Wird aufgerufen, um den Code zum Speichern
des Editorinhalts zu generieren

| |_onGetInsert­Method_ |$name |Wird aufgerufen, um den Code zum Einfügen
von Inhalten in den Editor zu generieren

| |_onDisplay_ |$name, $content, $width, $height, $col, $row, $buttons,
$id, $asset, $author |Wird aufgerufen, wenn der Editor angezeigt werden
soll

|Editors-XTD |_onDisplay_ |$name, $asset, $author |Wird aufgerufen, wenn
ein Button unterhalb des Editors hinzugefügt werden soll

|Extension |_onExtensionBeforeInstall_ |$method, $type, $manifest,
$extension |Wird vor der Installation einer Erweiterung aufgerufen

| |_onExtensionAfterInstall_ |$installer, $extension++_++id |Wird nach
der Installation einer Erweiterung aufgerufen

| |_onExtensionBeforeUpdate_ |$type, ­$manifest |Wird vor der
Aktualisierung einer Erweiterung aufgerufen

| |_onExtensionAfterUpdate_ |$installer, $extension++_++id |Wird nach
der Aktualisierung einer Erweiterung aufgerufen

| |_onExtensionBeforeUninstall_ |$extension++_++id |Wird vor der
Deinstallation einer Erweiterung aufgerufen

| |_onExtensionAfterUninstall_ |$installer, $extension++_++id, $result
|Wird nach der Deinstallation einer Erweiterung aufgerufen

| |_onExtensionAfterDelete_ |$context, &$item |Wird nach dem Löschen
einer Erweiterung aufgerufen

| |_onExtensionAfterSave_ |$context, $item |Wird nach dem Speichern
einer Erweiterung aufgerufen

| |_onExtensionBeforeDelete_ |$context, &$item |Wird vor dem Löschen
einer Erweiterung aufgerufen

| |_onExtensionBeforeSave_ |$context, $item |Wird vor dem Speichern
einer Erweiterung aufgerufen

|Installer |_onInstallerAddInstallationTab_ | |Wird beim Hinzufügen
eines neuen Tabs in den Installations-Dialog aufgerufen

| |_onInstallerAfterInstaller_ |$InstallerModelInstall, &$package,
$installer, &$result, &$msg |Wird aufgerufen, wenn ein
Installationsprozess abgeschlossen wurde

| |_onInstallerBeforeDisplay_ |&$showJedAndWebInstaller,
$InstallerModelInstall |Wird aufgerufen, bevor der Installationsdialog
angezeigt wird

| |_onInstallerBeforeInstallation_ |$InstallerModelInstall, &$package
|Wird vor der Installation eines Pakets aufgerufen

| |_onInstallerBeforeInstaller_ |$InstallerModelInstall, &$package |Wird
aufgerufen, bevor der Installationsprozess gestartet wird

| |_onInstallerBeforePackageDownload_ |&$url, &$headers |Wird vor dem
Download eines Pakets aufgerufen

| |_onInstallerViewAfterLastTab_ | |Wird aufgerufen nachdem der letzte
Tab im Installer gerendert wurde

| |_onInstallerViewBeforeFirstTab_ | |Wird aufgerufen bevor der erste
Tab im Instaler gerendert wurde

|Ajax |_onAjax$Group_ | |AJAX-Interface für Plugins, siehe
https://docs.joomla.org/Using++_++Joomla++_++Ajax++_++Interface

|twofactorauth |_onUserTwofactorIdentify_ | |Wird aufgerufen wenn ein
Nutzer mittels 2-Faktor-Authentifzierung authentifziert wird

|fields |_onCustomFieldsAfterPrepareField_ |$context, $item, $field,
&$value |Wird aufgerufen, nachdem ein eigenes Feld vorbereitet wurde

| |_onCustomFieldsBeforePrepareField_ |$context, $item, &$field |Wird
aufgerufen, bevor ein eigenes Feld vorbeitet wird

| |_onCustomFieldsGetTypes_ | |Wird aufgerufen, wenn die Liste der
verfügbaren Feldtypen zusammengestellt werden soll

| |_onCustomFieldsPrepareDom_ |$field, $fieldset, $form |Wird
aufgerufen, wenn das Markup eines Felds generiert werden soll

| |_onCustomFieldsPrepareField_ |$context, $item, &$field |Wird
aufgerufen, wenn ein Feld vorbereitet werden soll
|===
